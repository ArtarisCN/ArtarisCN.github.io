---
title: Java 的内存模型与 volatile 关键字
date: 2019-01-13 13:35:41
tags: [Java]
categories:
- Java
---

## Java 的内存模型
Java 的内存模型（Java Memory Model，JMM）定义了程序中变量的访问规则，即程序的执行次序。

<!-- more -->

Java内存模型规定所有的变量都是存在主存当中，每个线程都有自己的工作内存。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。
Java 内存模型为程序的原子性、可见性以及有序性的保证：
* 原子性
    对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。
    只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。

    _x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。_

    大范围的原子性操作通过 synchronized 和 Lock 来实现
* 可见性：
    Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
    而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。
    synchronized和Lock也能够保证可见性，
* 有序性
    在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。
    在Java里面，可以通过volatile关键字来保证一定的“有序性”
    Java 还具有一些先天的有序性，也称为 happens-before 原则，如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。
    * 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
    * 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
    * volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
    * 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C

## volatole 关键字
被 volatole 修饰的共享变量会具有两层含义：
　　1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。即**它会保证修改的值会立即被更新到主存**
　　2. 禁止进行指令重排序。保证被 volatile 修饰变量与其他指令的绝对顺序。

#### volatole 的实现原理
volatole 是通过内存屏障来实现加锁操作的
> “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”

lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：

* 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
* 它会强制将对缓存的修改操作立即写入主存；
* 如果是写操作，它会导致其他CPU中对应的缓存行无效。
