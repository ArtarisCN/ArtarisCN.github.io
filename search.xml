<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Activity 的加载模式</title>
    <url>/Android/Activity%20%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>Activity 的生命周期和加载模式是 Android 开发的基础，有些项目中的需求可以巧妙使用不同的加载模式来解决，之前使用 Android 加载模式时还有一些没有理解透彻的地方，在此做一个总结。此外，当打开已存在栈中的 Activity 时，并不会走<code>onCreate()</code>方法，而是会走<code>onNewIntent()</code>方法，在<code>onCreate()</code>做过的操作也会一并走一遍，在此也对这种情况做一个说明。</p>
<span id="more"></span>

<p>项目地址：<a href="https://github.com/ArtarisCN/ActivityLaunchModeDemo">ActivityLaunchModeDemo</a></p>
<p>Activity 的加载模式是在<code>AndroidManifest.xml</code>中设置的，具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.ui.activity.MainActivity&quot;</span><br><span class="line">  	  android:launchMode=&quot;singleTask&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Standard（默认）"><a href="#Standard（默认）" class="headerlink" title="Standard（默认）"></a>Standard（默认）</h4><p>如果不指定<code>launchMode</code>，则默认为<code>standard</code>。<br>当启动模式设置成<code>standard</code>时，每次生成新的 Activity ，就会在当前任务栈中生成新的页面。当打开一个新的页面时，其生命周期如下<br><img src="http://img.artaris.cn/activity_launch_model/stander_1.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On Create</span><br><span class="line">On Start</span><br><span class="line">On Resume</span><br></pre></td></tr></table></figure>
<p>当再次开启一个新的<code>standard</code>页面时，前一个Activity 的生命周期如下<br><img src="http://img.artaris.cn/activity_launch_model/stander_2.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On Pause</span><br><span class="line">On Stop</span><br></pre></td></tr></table></figure>

<p>新开的页面继续重复其生命周期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On Create</span><br><span class="line">On Start</span><br><span class="line">On Resume</span><br></pre></td></tr></table></figure>
<p>当关闭屏幕时，其生命周期如下<br><img src="http://img.artaris.cn/activity_launch_model/stander_6.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On Pause</span><br><span class="line"></span><br><span class="line">On Stop</span><br></pre></td></tr></table></figure>
<p>重新开启屏幕时，其生命周期如下<br><img src="http://img.artaris.cn/activity_launch_model/stander_3.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On Restart</span><br><span class="line">On Start</span><br><span class="line">On Resume</span><br></pre></td></tr></table></figure>
<p>当前任务栈如下<br><img src="http://img.artaris.cn/activity_launch_model/stander_4.jpg?imageMogr2/thumbnail/!30p"></p>
<h4 id="SingleTop"><a href="#SingleTop" class="headerlink" title="SingleTop"></a>SingleTop</h4><p><code>singleTop</code>其实和<code>standard</code>几乎一样，使用<code>singleTop</code>的 Activity 也可以创建很多个实例。唯一不同的就是，如果调用的目标 Activity 已经位于调用者的Task的栈顶，则不创建新实例，而是使用当前的这个 Activity 实例，并调用这个实例的 <code>onNewIntent()</code>方法。如果是外部程序跨应用启动singleTop的Activity，在Android 5.0之前新创建的Activity会位于调用者的Task中，5.0及以后会放入新的Task中。</p>
<p>当当前栈顶页面不是<code>singleTop</code>时，其效果与<code>standard</code>一样的，在此不再赘述。当前页面已经是<code>singleTop</code>，会使用当前实例，点击新开<code>singleTop</code>其生命周期如下<br><img src="http://img.artaris.cn/activity_launch_model/single_top_5.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On Pause</span><br><span class="line">On New Intent</span><br><span class="line">On Resume</span><br></pre></td></tr></table></figure>

<p>可以看到，新开的页面并没有重新创建，而是调用了顶端 Activity 的<code>onNewIntent()</code>方法。</p>
<h4 id="SingleTask"><a href="#SingleTask" class="headerlink" title="SingleTask"></a>SingleTask</h4><ul>
<li>在同一程序时<br><code>singleTask</code>简单来说，就是当前栈中只有一个该页面的实例。使用<code>singleTask</code>创建新的 Activity 时会先检查当前栈中是否有此实例，如果有这个实例，则会将此实例之上所有的 Activity 统统出栈，使此Activity实例成为栈顶对象，显示到幕前，然后调用 <code>onNewIntent()</code>方法。<br>调用前栈内信息如下：<br><img src="http://img.artaris.cn/activity_launch_model/single_task_1.jpg?imageMogr2/thumbnail/!30p"><br>可以看到当前<code>singleTask</code>页面为第三个页面（其上还有两个<code>standard</code>页面），这时我们点击生成<code>singleTask</code>页面，任务栈变化如下<br><img src="http://img.artaris.cn/activity_launch_model/single_task_2.jpg?imageMogr2/thumbnail/!30p"><br>在栈中的<code>singleTask</code>的生命周期变化如下<br><img src="http://img.artaris.cn/activity_launch_model/single_task_3.png"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On New Intent</span><br><span class="line">On Restart</span><br><span class="line">On Start</span><br><span class="line">On Resume</span><br></pre></td></tr></table></figure></li>
<li>不同程序之间</li>
</ul>
<ol>
<li>在跨应用Intent传递时，如果系统中不存在singleTask Activity的实例，那么将创建一个新Task，然后创建SingleTask Activity实例，将其放入新的Task中。</li>
<li>如果singleTask Activity所在的应用进程存在，但是singleTask Activity实例不存在，那么从别的应用启动这个Activity，新的Activity实例会被创建，并放入到所属进程所在的Task中，并位于栈顶位置。</li>
<li>更复杂的一种情况，如果singleTask Activity实例存在，从其他程序被启动，那么这个Activity所在的Task会被移到顶部，并且在这个Task中，位于singleTask Activity实例之上的所有Activity将会被正常销毁掉。如果我们按返回键，那么我们首先会回退到这个Task中的其他Activity，直到当前Task的Activity回退栈为空时，才会返回到调用者的Task。</li>
</ol>
<h4 id="SingleInstance"><a href="#SingleInstance" class="headerlink" title="SingleInstance"></a>SingleInstance</h4><p><code>singleInstance</code>模式下无论在任何任务栈启动，全局都只会有一个 <code>singleInstance</code> 实例。如果在<code>singleInstance</code> 启动其他模式的页面，那么这个其他页面的实例会放入其他任务栈中。就是说<code>singleInstance</code>会在一个单独的全新的任务栈中。</p>
<p>当从其他页面跳到<code>singleInstance</code>时重新启用了一个新的栈结构，来放置<code>singleInstance</code>实例，然后按下后退键，再次回到原始栈结构；<br>如果在<code>singleInstance</code>页面新开一个<code>standard</code> 页面，则会在原栈中生成一个页面，<code>singleInstance</code>依然存在，当在原栈中点击返回两次，则会关闭原栈，页面会切到<code>singleInstance</code>页面。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>ADB 使用指南</title>
    <url>/Android/ADB%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>ADB 的全称是 Android Debug Bridge,在以前仅仅是用它来安装应用、存取文件等简单操作。细细学习了解之后才发现 ADB 还能实现很多强大的功能。在此总结一下 ADB 的一些常用功能</p>
<span id="more"></span>

<ul>
<li><a href="#%E8%AF%AD%E6%B3%95%E5%8F%8A%E8%BF%9E%E6%8E%A5">语法及连接</a><ul>
<li><a href="#%E8%AF%AD%E6%B3%95">语法</a></li>
<li><a href="#%E8%BF%9E%E6%8E%A5">连接</a><ul>
<li><a href="#usb-%E8%BF%9E%E6%8E%A5">USB 连接</a></li>
<li><a href="#%E6%97%A0%E7%BA%BF%E8%BF%9E%E6%8E%A5">无线连接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF">获取设备信息</a><ul>
<li><a href="#%E5%9E%8B%E5%8F%B7">型号</a></li>
<li><a href="#%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87">屏幕分辨率</a></li>
<li><a href="#%E5%B1%8F%E5%B9%95%E5%AF%86%E5%BA%A6">屏幕密度</a></li>
<li><a href="#ip-%E5%9C%B0%E5%9D%80">IP 地址</a></li>
<li><a href="#IMEI">IMEI</a></li>
<li><a href="#android-%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC">Android 系统版本</a></li>
<li><a href="#cpu-%E4%BF%A1%E6%81%AF">CPU 信息</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86">文件管理</a><ul>
<li><a href="#%E6%8B%89%E5%8F%96">拉取</a></li>
<li><a href="#%E6%8E%A8%E9%80%81">推送</a></li>
</ul>
</li>
<li><a href="#%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86">应用管理</a><ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E5%AE%89%E8%A3%85%E5%BA%94%E7%94%A8">查看设备安装应用</a><ul>
<li><a href="#%E6%89%80%E7%94%A8%E5%BA%94%E7%94%A8">所有应用</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E7%BA%A7%E5%BA%94%E7%94%A8">系统级应用</a></li>
<li><a href="#%E7%94%A8%E6%88%B7%E5%AE%89%E8%A3%85%E5%BA%94%E7%94%A8">用户安装应用</a></li>
<li><a href="#%E8%BF%87%E6%BB%A4%E6%98%BE%E7%A4%BA">过滤显示</a></li>
</ul>
</li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85">应用安装</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%8D%B8%E8%BD%BD">应用卸载</a></li>
<li><a href="#%E6%B8%85%E9%99%A4%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BC%93%E5%AD%98">清除应用数据与缓存</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%89%8D%E5%8F%B0-activity">查看前台 Activity</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84-services">查看正在运行的 Services</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF">查看应用详细信息</a></li>
</ul>
</li>
<li><a href="#%E6%93%8D%E4%BD%9C%E6%A8%A1%E6%8B%9F">操作模拟</a><ul>
<li><a href="#%E6%8C%89%E9%94%AE%E6%A8%A1%E6%8B%9F">按键模拟</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E4%BA%A4%E4%BA%92">应用交互</a><ul>
<li><a href="#%E8%B0%83%E8%B5%B7-activity">调起 Activity</a></li>
<li><a href="#%E8%B0%83%E8%B5%B7-service">调起 Service</a></li>
<li><a href="#%E5%8F%91%E9%80%81%E5%B9%BF%E6%92%AD">发送广播</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%BA%94%E7%94%A8">强制停止应用</a></li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E5%A4%87%E6%93%8D%E4%BD%9C">设备操作</a><ul>
<li><a href="#%E6%88%AA%E5%B1%8F">截屏</a></li>
<li><a href="#%E5%BD%95%E5%B1%8F">录屏</a></li>
<li><a href="#%E9%87%8D%E5%90%AF">重启</a></li>
<li><a href="#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95-monkey">压力测试（Monkey）</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E5%88%86%E8%BE%A8%E7%8E%87">修改分辨率</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Log-%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B">Log 日志查看</a><ul>
<li><a href="#%E8%BF%87%E6%BB%A4%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA">过滤日志输出</a><ul>
<li><a href="#%E6%8C%89%E7%BA%A7%E5%88%AB%E8%BF%87%E6%BB%A4%E6%97%A5%E5%BF%97">按级别过滤日志</a></li>
<li><a href="#%E6%8C%89-Tag-%E8%BF%87%E6%BB%A4%E6%97%A5%E5%BF%97">按 Tag 过滤日志</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#adb-shell-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">ADB Shell 相关命令</a><ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B">查看进程</a></li>
</ul>
</li>
</ul>
<h2 id="语法及连接"><a href="#语法及连接" class="headerlink" title="语法及连接"></a>语法及连接</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>ADB 的基本命令语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt;</span><br></pre></td></tr></table></figure>
<p>同一台电脑可以连接多个 Android 设备，当时用 adb 命令操作设备的时候，可以指定设备下发命令。具体如下</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td>指定当前唯一通过 USB 连接的 Android 设备为命令目标</td>
</tr>
<tr>
<td>-e</td>
<td>指定当前唯一运行的模拟器为命令目标</td>
</tr>
<tr>
<td><code>-s &lt;Serial Number&gt;</code></td>
<td>指定相应 Serial Number 号的设备&#x2F;模拟器为命令目标</td>
</tr>
</tbody></table>
<p>可以使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>
<p>来查看当前连接的所有设备，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">emulator-5554   device</span><br><span class="line">e8c63296        device</span><br></pre></td></tr></table></figure>
<p><code>emulator-5554</code>是一个模拟器，<code>e8c63296</code> 是一台真机，这些均为他们的 Serial Number。可以指定设备发送命令，当只连接一台设备的时候，Serial Number 可以忽略不写。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>上文中介绍使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>
<p>可以查看所有连接到的设备。</p>
<h4 id="USB-连接"><a href="#USB-连接" class="headerlink" title="USB 连接"></a>USB 连接</h4><p>使用USB 连接设备时。需要将设备<br>的开发者选项和 USB 调试模式开启。<br>可以到「设置」-「开发者选项」-「Android 调试」查看。<br>如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。</p>
<h4 id="无线连接"><a href="#无线连接" class="headerlink" title="无线连接"></a>无线连接</h4><p>无线连接可以在提前设置的情况下，免去数据线连接的烦恼，不过每次打包的时候，将 APK 发送到设备上都需要一会，数据传输自然是没有使用数据线快了，受网络干扰因素影响。<br>无线连接必须保证将 Android 设备与要运行 ADB 的电脑连接到同一个局域网，比如连到同一个 WiFi 即可。<br>具体步骤如下：</p>
<ol>
<li>将设备与电脑通过 USB 线连接并确保能够连接成功（<code>adb devices</code>指令能够看见设备）；</li>
<li>让设备在 5555 端口监听 TCP&#x2F;IP 连接；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb connect &lt;device-ip-address&gt;</span><br></pre></td></tr></table></figure></li>
<li>拔掉数据线；</li>
<li>查找设备的 IP 地址，一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到；</li>
<li>通过 IP 地址连接设备   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb connect &lt;Device IP Address&gt;</span><br></pre></td></tr></table></figure>
<code>&lt;Device IP Address&gt;</code>即是刚才获取的 IP 地址<br>此时再使用<code>adb devices</code>命令，如果在下面能看见设备说明连接成功。</li>
</ol>
<h2 id="获取设备信息"><a href="#获取设备信息" class="headerlink" title="获取设备信息"></a>获取设备信息</h2><h3 id="型号"><a href="#型号" class="headerlink" title="型号"></a>型号</h3><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell getprop ro.product.model</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ONEPLUS A3010</span><br></pre></td></tr></table></figure>
<p>我手中的这台是一加 3T，型号为A3010</p>
<h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell wm size</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Physical size: 1080x1920</span><br></pre></td></tr></table></figure>
<p>我手中的这台一加 3T 的分辨率为 1080P</p>
<h3 id="屏幕密度"><a href="#屏幕密度" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell wm density</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Physical density: 420</span><br></pre></td></tr></table></figure>
<p>一加 3T 的 DPI 为 420DPI</p>
<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell ifconfig</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lo        Link encap:UNSPEC</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope: Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:475045 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:475045 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:692847495 TX bytes:692847495</span><br><span class="line"></span><br><span class="line">dummy0    Link encap:UNSPEC</span><br><span class="line">          inet6 addr: fe80::4c8a:30ff:fec6:13fc/64 Scope: Link</span><br><span class="line">          UP BROADCAST RUNNING NOARP  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:115 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:0 TX bytes:8050</span><br><span class="line"></span><br><span class="line">wlan0     Link encap:UNSPEC    Driver cnss_wlan_pci</span><br><span class="line">          inet addr:192.168.31.86  Bcast:192.168.31.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::9665:2dff:fe25:12f5/64 Scope: Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:2465828 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:138772 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:3000</span><br><span class="line">          RX bytes:475187452 TX bytes:49284101</span><br><span class="line"></span><br><span class="line">rmnet_ipa0 Link encap:UNSPEC</span><br><span class="line">          UP RUNNING  MTU:2000  Metric:1</span><br><span class="line">          RX packets:1897 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:3233 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:2042241 TX bytes:490601</span><br><span class="line"></span><br><span class="line">p2p0      Link encap:UNSPEC    Driver cnss_wlan_pci</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:3000</span><br><span class="line">          RX bytes:0 TX bytes:0</span><br></pre></td></tr></table></figure>
<p>我现在正使用局域网，<code>wlan0 inet addr:192.168.31.86</code>即是我的 IP 地址</p>
<h3 id="IMEI"><a href="#IMEI" class="headerlink" title="IMEI"></a>IMEI</h3><p>在 Android 4.4 及以下版本可通过如下命令获取 IMEI：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys iphonesubinfo</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Phone Subscriber Info:</span><br><span class="line">  Phone Type = GSM</span><br><span class="line">  Device ID = 860955027785041</span><br></pre></td></tr></table></figure>
<p> Android 5.0 上需要 ROOT 权限才能看到</p>
<h3 id="Android-系统版本"><a href="#Android-系统版本" class="headerlink" title="Android 系统版本"></a>Android 系统版本</h3><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell getprop ro.build.version.release</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8.0.0</span><br></pre></td></tr></table></figure>
<p>我手中的这台一加 3T 的 Android 版本为奥利奥</p>
<h3 id="CPU-信息"><a href="#CPU-信息" class="headerlink" title="CPU 信息"></a>CPU 信息</h3><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">processor       : 0</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line">Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32</span><br><span class="line">CPU implementer : 0x51</span><br><span class="line">CPU architecture: 8</span><br><span class="line">CPU variant     : 0x2</span><br><span class="line">CPU part        : 0x201</span><br><span class="line">CPU revision    : 1</span><br><span class="line"></span><br><span class="line">processor       : 1</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line">Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32</span><br><span class="line">CPU implementer : 0x51</span><br><span class="line">CPU architecture: 8</span><br><span class="line">CPU variant     : 0x2</span><br><span class="line">CPU part        : 0x201</span><br><span class="line">CPU revision    : 1</span><br><span class="line"></span><br><span class="line">processor       : 2</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line">Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32</span><br><span class="line">CPU implementer : 0x51</span><br><span class="line">CPU architecture: 8</span><br><span class="line">CPU variant     : 0x2</span><br><span class="line">CPU part        : 0x205</span><br><span class="line">CPU revision    : 1</span><br><span class="line"></span><br><span class="line">processor       : 3</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line">Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32</span><br><span class="line">CPU implementer : 0x51</span><br><span class="line">CPU architecture: 8</span><br><span class="line">CPU variant     : 0x2</span><br><span class="line">CPU part        : 0x205</span><br><span class="line">CPU revision    : 1</span><br><span class="line"></span><br><span class="line">Hardware        : Qualcomm Technologies, Inc MSM8996pro</span><br></pre></td></tr></table></figure>
<p>看到使用的硬件是 <code>Qualcomm MSM8996pro</code>，即高通 821，processor 的编号是 0 到 3，所以它是四核的。</p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pull &lt;设备里的文件路径&gt; [电脑上的目录]</span><br></pre></td></tr></table></figure>
<p>如果省略<code>[电脑上的目录]</code>选项，则默认复制在当前目录下；<br>一般使用未 ROOT 的机器均是复制或拉取 <code>/sdcard/</code>目录下的文件。<br>eg.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pull /sdcard/demo.mp4 ~/Desktop</span><br></pre></td></tr></table></figure>
<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt;</span><br></pre></td></tr></table></figure>
<p>eg.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push ~/Desktop/demo.mp4 /sdcard/</span><br></pre></td></tr></table></figure>
<h2 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h2><h3 id="查看设备安装应用"><a href="#查看设备安装应用" class="headerlink" title="查看设备安装应用"></a>查看设备安装应用</h3><p>查看应用列表的基本命令格式是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages [-f]/[-d]/[-e]/[-s]/[-3]/[-i]/[-u]/[--user USER_ID]/[FILTER]</span><br></pre></td></tr></table></figure>

<p>这些参数的含义如下所示</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>显示列表</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>所有应用</td>
</tr>
<tr>
<td>-f</td>
<td>显示应用关联的 apk 文件</td>
</tr>
<tr>
<td>-d</td>
<td>只显示 disabled 的应用</td>
</tr>
<tr>
<td>-e</td>
<td>只显示 enabled 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>只显示系统应用</td>
</tr>
<tr>
<td>-3</td>
<td>只显示第三方应用</td>
</tr>
<tr>
<td>-i</td>
<td>显示应用的 installer</td>
</tr>
<tr>
<td>-u</td>
<td>包含已卸载应用</td>
</tr>
<tr>
<td><code>&lt;FILTER&gt;</code></td>
<td>包名包含 <code>&lt;FILTER&gt;</code> 字符串</td>
</tr>
</tbody></table>
<p>下面是具体例子：</p>
<h4 id="所用应用"><a href="#所用应用" class="headerlink" title="所用应用"></a>所用应用</h4><p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package:com.oneplus.calculator</span><br><span class="line">package:net.oneplus.weather</span><br><span class="line">package:com.android.cts.priv.ctsshim</span><br><span class="line">package:com.oneplus.market</span><br><span class="line">package:com.yulore.framework</span><br><span class="line">package:com.android.providers.telephony</span><br><span class="line">package:com.sony.playmemories.mobile</span><br><span class="line">package:com.android.engineeringmode</span><br><span class="line">package:com.android.providers.calendar</span><br><span class="line">package:com.oneplus.opbugreport</span><br><span class="line">package:com.oneplus.card</span><br><span class="line">package:com.oneplus.note</span><br><span class="line">package:com.oneplus.skin</span><br><span class="line">package:com.android.providers.media</span><br><span class="line">package:com.sohu.inputmethod.sogou</span><br><span class="line">package:com.android.wallpapercropper</span><br><span class="line">package:com.oneplus.account</span><br><span class="line">package:com.quicinc.cne.CNEService</span><br><span class="line">package:com.oneplus.soundrecorder</span><br><span class="line">package:com.qualcomm.qti.autoregistration</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="系统级应用"><a href="#系统级应用" class="headerlink" title="系统级应用"></a>系统级应用</h4><p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages -s</span><br></pre></td></tr></table></figure>
<h4 id="用户安装应用"><a href="#用户安装应用" class="headerlink" title="用户安装应用"></a>用户安装应用</h4><p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages -3</span><br></pre></td></tr></table></figure>
<h4 id="过滤显示"><a href="#过滤显示" class="headerlink" title="过滤显示"></a>过滤显示</h4><p>比如要查看包名包含字符串 <code>tencent</code> 的应用列表，命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages tencent</span><br></pre></td></tr></table></figure>
<p>则只会输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package:com.tencent.mm</span><br><span class="line">package:com.tencent.mobileqq</span><br></pre></td></tr></table></figure>
<h3 id="应用安装"><a href="#应用安装" class="headerlink" title="应用安装"></a>应用安装</h3><p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb install [-l]/[-r]/[-t]/[-s]/[-d]/[-g] &lt;path_to_apk&gt;</span><br></pre></td></tr></table></figure>
<p>这些参数的含义如下所示</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>将应用安装到保护目录 &#x2F;mnt&#x2F;asec</td>
</tr>
<tr>
<td>-r</td>
<td>允许覆盖安装</td>
</tr>
<tr>
<td>-t</td>
<td>允许安装 AndroidManifest.xml 里 application 指定 <code>android:testOnly=&quot;true&quot;</code> 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>将应用安装到 sdcard</td>
</tr>
<tr>
<td>-d</td>
<td>允许降级覆盖安装</td>
</tr>
<tr>
<td>-g</td>
<td>授予所有运行时权限</td>
</tr>
</tbody></table>
<p>运行命令后见到输出状态为 <code>Success</code>代表安装成功。<br>如果失败则会输出<code>Failure</code>及错误码，常见错误码含义如下：</p>
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
<th>解决办法</th>
</tr>
</thead>
<tbody><tr>
<td>INSTALL_FAILED_ALREADY_EXISTS</td>
<td>应用已经存在，或卸载了但没卸载干净</td>
<td><code>adb install</code> 时使用 <code>-r</code> 参数，或者先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_APK</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_URI</td>
<td>无效的 APK 文件名</td>
<td>确保 APK 文件名里无中文</td>
</tr>
<tr>
<td>INSTALL_FAILED_INSUFFICIENT_STORAGE</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PACKAGE</td>
<td>已经存在同名程序</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_SHARED_USER</td>
<td>请求的共享用户不存在</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UPDATE_INCOMPATIBLE</td>
<td>以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致</td>
<td>先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_SHARED_USER_INCOMPATIBLE</td>
<td>请求的共享用户存在但签名不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_SHARED_LIBRARY</td>
<td>安装包使用了设备上不可用的共享库</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_REPLACE_COULDNT_DELETE</td>
<td>替换时无法删除</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_DEXOPT</td>
<td>dex 优化验证失败或空间不足</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_OLDER_SDK</td>
<td>设备系统版本低于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONFLICTING_PROVIDER</td>
<td>设备里已经存在与应用里同名的 content provider</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NEWER_SDK</td>
<td>设备系统版本高于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_TEST_ONLY</td>
<td>应用是 test-only 的，但安装时没有指定 <code>-t</code> 参数</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CPU_ABI_INCOMPATIBLE</td>
<td>包含不兼容设备 CPU 应用程序二进制接口的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_FEATURE</td>
<td>应用使用了设备不可用的功能</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONTAINER_ERROR</td>
<td>1. sdcard 访问失败;<br />2. 应用签名与 ROM 签名一致，被当作内置应用。</td>
<td>1. 确认 sdcard 可用，或者安装到内置存储;<br />2. 打包时不与 ROM 使用相同签名。</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_INSTALL_LOCATION</td>
<td>1. 不能安装到指定位置;<br />2. 应用签名与 ROM 签名一致，被当作内置应用。</td>
<td>1. 切换安装位置，添加或删除 <code>-s</code> 参数;<br />2. 打包时不与 ROM 使用相同签名。</td>
</tr>
<tr>
<td>INSTALL_FAILED_MEDIA_UNAVAILABLE</td>
<td>安装位置不可用</td>
<td>一般为 sdcard，确认 sdcard 可用或安装到内置存储</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_TIMEOUT</td>
<td>验证安装包超时</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_FAILURE</td>
<td>验证安装包失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_PACKAGE_CHANGED</td>
<td>应用与调用程序期望的不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UID_CHANGED</td>
<td>以前安装过该应用，与本次分配的 UID 不一致</td>
<td>清除以前安装过的残留文件</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERSION_DOWNGRADE</td>
<td>已经安装了该应用更高版本</td>
<td>使用 <code>-d</code> 参数</td>
</tr>
<tr>
<td>INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE</td>
<td>已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NOT_APK</td>
<td>指定路径不是文件，或不是以 <code>.apk</code> 结尾</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_MANIFEST</td>
<td>无法解析的 AndroidManifest.xml 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION</td>
<td>解析器遇到异常</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NO_CERTIFICATES</td>
<td>安装包没有签名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES</td>
<td>已安装该应用，且签名与 APK 文件不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING</td>
<td>解析 APK 文件时遇到 <code>CertificateEncodingException</code></td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME</td>
<td>manifest 文件里没有或者使用了无效的包名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID</td>
<td>manifest 文件里指定了无效的共享用户 ID</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_MALFORMED</td>
<td>解析 manifest 文件时遇到结构性错误</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_EMPTY</td>
<td>在 manifest 文件里找不到找可操作标签（instrumentation 或 application）</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INTERNAL_ERROR</td>
<td>因系统问题安装失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_USER_RESTRICTED</td>
<td>用户被限制安装应用</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PERMISSION</td>
<td>应用尝试定义一个已经存在的权限名称</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_MATCHING_ABIS</td>
<td>应用包含设备的应用程序二进制接口不支持的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_CANCELED_BY_USER</td>
<td>应用安装需要在设备上确认，但未操作设备或点了取消</td>
<td>在设备上同意安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_ACWF_INCOMPATIBLE</td>
<td>应用程序与设备不兼容</td>
<td></td>
</tr>
<tr>
<td>does not contain AndroidManifest.xml</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>is not a valid zip file</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>Offline</td>
<td>设备未连接成功</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>unauthorized</td>
<td>设备未授权允许调试</td>
<td></td>
</tr>
<tr>
<td>error: device not found</td>
<td>没有连接成功的设备</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>protocol failure</td>
<td>设备已断开连接</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>Unknown option: -s</td>
<td>Android 2.2 以下不支持安装到 sdcard</td>
<td>不使用 <code>-s</code> 参数</td>
</tr>
<tr>
<td>No space left on device</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>Permission denied … sdcard …</td>
<td>sdcard 不可用</td>
<td></td>
</tr>
<tr>
<td>signatures do not match the previously installed version; ignoring!</td>
<td>已安装该应用且签名不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
</tbody></table>
<p><strong><code>adb install</code> 内部原理简介</strong></p>
<p><code>adb install</code> 实际是分三步完成：</p>
<ol>
<li><p>push apk 文件到 &#x2F;data&#x2F;local&#x2F;tmp。</p>
</li>
<li><p>调用 pm install 安装。</p>
</li>
<li><p>删除 &#x2F;data&#x2F;local&#x2F;tmp 下的对应 apk 文件。</p>
</li>
</ol>
<p>所以，如果有需要也可以根据这个步骤，手动分步执行安装过程。</p>
<h3 id="应用卸载"><a href="#应用卸载" class="headerlink" title="应用卸载"></a>应用卸载</h3><p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb uninstall [-k] &lt;packagename&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;packagename&gt;</code> 表示应用的包名，<code>-k</code> 参数可选，表示卸载应用但保留数据和缓存目录。</p>
<p>命令示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb uninstall com.tencent.mobileqq</span><br></pre></td></tr></table></figure>
<p>即卸载 QQ</p>
<h3 id="清除应用数据与缓存"><a href="#清除应用数据与缓存" class="headerlink" title="清除应用数据与缓存"></a>清除应用数据与缓存</h3><p>这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。<br>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm clear &lt;packagename&gt;</span><br></pre></td></tr></table></figure>

<p>命令示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm clear com.tencent.mobileqq</span><br></pre></td></tr></table></figure>
<p>即清除 QQ 的缓存和数据</p>
<h3 id="查看前台-Activity"><a href="#查看前台-Activity" class="headerlink" title="查看前台 Activity"></a>查看前台 Activity</h3><p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity activities | grep mFocusedActivity</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mFocusedActivity: ActivityRecord&#123;8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42&#125;</span><br></pre></td></tr></table></figure>

<p>其中的 <code>com.cyanogenmod.trebuchet/com.android.launcher3.Launcher</code> 就是当前处于前台的 Activity。</p>
<p>当然，输入以下命令就可以查看所有 Activity 栈了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity activities</span><br></pre></td></tr></table></figure>

<h3 id="查看正在运行的-Services"><a href="#查看正在运行的-Services" class="headerlink" title="查看正在运行的 Services"></a>查看正在运行的 Services</h3><p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity services [&lt;packagename&gt;]</span><br></pre></td></tr></table></figure>

<p><code>&lt;packagename&gt;</code> 参数不是必须的，指定 <code>&lt;packagename&gt;</code> 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。</p>
<p><code>&lt;packagename&gt;</code> 不一定要给出完整的包名，比如运行 <code>adb shell dumpsys activity services cn.artaris</code>，那么包名 <code>cn.artaris.demo1</code>、<code>cn.artaris.demo2</code> 和 <code>cn.artaris123</code> 等相关的 Services 都会列出来。</p>
<h3 id="查看应用详细信息"><a href="#查看应用详细信息" class="headerlink" title="查看应用详细信息"></a>查看应用详细信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys package &lt;packagename&gt;</span><br></pre></td></tr></table></figure>

<p>输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。</p>
<p><code>&lt;packagename&gt;</code> 表示应用包名。</p>
<h2 id="操作模拟"><a href="#操作模拟" class="headerlink" title="操作模拟"></a>操作模拟</h2><h3 id="按键模拟"><a href="#按键模拟" class="headerlink" title="按键模拟"></a>按键模拟</h3><p>按键模拟主要是通过<code>adb shell input</code>来实现的，在 Android 开发的时候我们可以拦截按键事件，接受按键的函数如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onKeyDown(int keyCode, KeyEvent event) &#123;</span><br><span class="line">    return super.onKeyDown(keyCode, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>KeyEvent</code>类中定义了一系列常量，例如返回键的值为<code>KeyEvent.KEYCODE_BACK</code>，其常量值为4。按键模拟操作的值与此一致。<br>下表为常用按键值：</p>
<table>
<thead>
<tr>
<th>keycode</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>HOME 键</td>
</tr>
<tr>
<td>4</td>
<td>返回键</td>
</tr>
<tr>
<td>5</td>
<td>打开拨号应用</td>
</tr>
<tr>
<td>6</td>
<td>挂断电话</td>
</tr>
<tr>
<td>24</td>
<td>增加音量</td>
</tr>
<tr>
<td>25</td>
<td>降低音量</td>
</tr>
<tr>
<td>26</td>
<td>电源键</td>
</tr>
<tr>
<td>27</td>
<td>拍照（需要在相机应用里）</td>
</tr>
<tr>
<td>64</td>
<td>打开浏览器</td>
</tr>
<tr>
<td>82</td>
<td>菜单键</td>
</tr>
<tr>
<td>85</td>
<td>播放&#x2F;暂停</td>
</tr>
<tr>
<td>86</td>
<td>停止播放</td>
</tr>
<tr>
<td>87</td>
<td>播放下一首</td>
</tr>
<tr>
<td>88</td>
<td>播放上一首</td>
</tr>
<tr>
<td>122</td>
<td>移动光标到行首或列表顶部</td>
</tr>
<tr>
<td>123</td>
<td>移动光标到行末或列表底部</td>
</tr>
<tr>
<td>126</td>
<td>恢复播放</td>
</tr>
<tr>
<td>127</td>
<td>暂停播放</td>
</tr>
<tr>
<td>164</td>
<td>静音</td>
</tr>
<tr>
<td>176</td>
<td>打开系统设置</td>
</tr>
<tr>
<td>187</td>
<td>切换应用</td>
</tr>
<tr>
<td>207</td>
<td>打开联系人</td>
</tr>
<tr>
<td>208</td>
<td>打开日历</td>
</tr>
<tr>
<td>209</td>
<td>打开音乐</td>
</tr>
<tr>
<td>210</td>
<td>打开计算器</td>
</tr>
<tr>
<td>220</td>
<td>降低屏幕亮度</td>
</tr>
<tr>
<td>221</td>
<td>提高屏幕亮度</td>
</tr>
<tr>
<td>223</td>
<td>系统休眠</td>
</tr>
<tr>
<td>224</td>
<td>点亮屏幕</td>
</tr>
<tr>
<td>231</td>
<td>打开语音助手</td>
</tr>
<tr>
<td>276</td>
<td>如果没有 wakelock 则让系统休眠</td>
</tr>
</tbody></table>
<p>使用方法如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent &lt;KeyCode&gt;</span><br></pre></td></tr></table></figure>
<p>只要输入对应按键的按键号，则能实现对应功能。</p>
<p>有两个操作需要特别说明一下：</p>
<h4 id="模拟屏幕滑动："><a href="#模拟屏幕滑动：" class="headerlink" title="模拟屏幕滑动："></a>模拟屏幕滑动：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input swipe 300 1000 300 500</span><br></pre></td></tr></table></figure>
<p>参数 <code>300 1000 300 500</code> 分别表示<code>起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标</code>。</p>
<h4 id="输入文本："><a href="#输入文本：" class="headerlink" title="输入文本："></a>输入文本：</h4><p>在焦点处于某文本框时，可以通过 <code>input</code> 命令来输入文本。</p>
<p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input text artaris</span><br></pre></td></tr></table></figure>

<p>现在 <code>artaris</code> 出现在文本框了。</p>
<h3 id="应用交互"><a href="#应用交互" class="headerlink" title="应用交互"></a>应用交互</h3><p>应用交互主要是通过<code>adb shell am &lt;command&gt;</code>来实现的,常用的<code>&lt;command&gt;</code>指令有以下几种：</p>
<table>
<thead>
<tr>
<th>command</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>start [options] &lt;INTENT&gt;</code></td>
<td>启动 <code>&lt;INTENT&gt;</code> 指定的 Activity</td>
</tr>
<tr>
<td><code>startservice [options] &lt;INTENT&gt;</code></td>
<td>启动 <code>&lt;INTENT&gt;</code> 指定的 Service</td>
</tr>
<tr>
<td><code>broadcast [options] &lt;INTENT&gt;</code></td>
<td>发送 <code>&lt;INTENT&gt;</code> 指定的广播</td>
</tr>
<tr>
<td><code>force-stop &lt;packagename&gt;</code></td>
<td>停止 <code>&lt;packagename&gt;</code> 相关的进程</td>
</tr>
</tbody></table>
<p><code>&lt;INTENT&gt;</code> 即与 Android 程序时代码里的 Intent 相对应。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-a &lt;ACTION&gt;</code></td>
<td>指定 action，比如 <code>android.intent.action.VIEW</code></td>
</tr>
<tr>
<td><code>-c &lt;CATEGORY&gt;</code></td>
<td>指定 category，比如 <code>android.intent.category.APP_CONTACTS</code></td>
</tr>
<tr>
<td><code>-n &lt;COMPONENT&gt;</code></td>
<td>指定完整 component 名，用于明确指定启动哪个 Activity，如 <code>cn.artaris.demo/.MainActivity</code></td>
</tr>
</tbody></table>
<p><code>&lt;INTENT&gt;</code> 里还能带参数，与程序中的 Bundle 含义一致：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>--esn &lt;EXTRA_KEY&gt;</code></td>
<td>null 值（只有 key 名）</td>
</tr>
<tr>
<td><code>-e/--es &lt;EXTRA_KEY&gt; &lt;EXTRA_STRING_VALUE&gt;</code></td>
<td>string 值</td>
</tr>
<tr>
<td><code>--ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt;</code></td>
<td>boolean 值</td>
</tr>
<tr>
<td><code>--ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;</code></td>
<td>integer 值</td>
</tr>
<tr>
<td><code>--el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;</code></td>
<td>long 值</td>
</tr>
<tr>
<td><code>--ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt;</code></td>
<td>float 值</td>
</tr>
<tr>
<td><code>--eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt;</code></td>
<td>URI</td>
</tr>
<tr>
<td><code>--ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt;</code></td>
<td>component name</td>
</tr>
<tr>
<td><code>--eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...]</code></td>
<td>integer 数组</td>
</tr>
<tr>
<td><code>--ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...]</code></td>
<td>long 数组</td>
</tr>
</tbody></table>
<h4 id="调起-Activity"><a href="#调起-Activity" class="headerlink" title="调起 Activity"></a>调起 Activity</h4><p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am start [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>
<p>eg.：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am start -n com.tencent.mm/.ui.LauncherUI</span><br></pre></td></tr></table></figure>
<p>即掉起微信主界面；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am start -n cn.artaris.demo/.MainActivity --es &quot;toast&quot; &quot;hello, world&quot;</span><br></pre></td></tr></table></figure>
<p>表示调起 <code>cn.artaris.demo/.MainActivity</code> 并传给它 String 数据键值对 <code>toast - hello, world</code>。</p>
<h4 id="调起-Service"><a href="#调起-Service" class="headerlink" title="调起 Service"></a>调起 Service</h4><p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am startservice [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService</span><br></pre></td></tr></table></figure>

<p>表示调起微信的 AccountAuthenticatorService。</p>
<h4 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h4><p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>
<p>使用该命令可以向所有组件广播，也可以只向指定组件广播；<br>eg.:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED</span><br></pre></td></tr></table></figure>
<p>向所有应用发送开机广播。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n cn.artaris.demo/.BootReceiver</span><br></pre></td></tr></table></figure>
<p>只向<code>cn.artaris.demo/.BootReceiver</code>发送开机广播；<br>以下是常用系统广播，可以模拟一些特殊场景：</p>
<table>
<thead>
<tr>
<th>action</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td>android.net.conn.CONNECTIVITY_CHANGE</td>
<td>网络连接发生变化</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_ON</td>
<td>屏幕点亮</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_OFF</td>
<td>屏幕熄灭</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_LOW</td>
<td>电量低，会弹出电量低提示框</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_OKAY</td>
<td>电量恢复了</td>
</tr>
<tr>
<td>android.intent.action.BOOT_COMPLETED</td>
<td>设备启动完毕</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_LOW</td>
<td>存储空间过低</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_OK</td>
<td>存储空间恢复</td>
</tr>
<tr>
<td>android.intent.action.PACKAGE_ADDED</td>
<td>安装了新的应用</td>
</tr>
<tr>
<td>android.net.wifi.STATE_CHANGE</td>
<td>WiFi 连接状态发生变化</td>
</tr>
<tr>
<td>android.net.wifi.WIFI_STATE_CHANGED</td>
<td>WiFi 状态变为启用&#x2F;关闭&#x2F;正在启动&#x2F;正在关闭&#x2F;未知</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_CHANGED</td>
<td>电池电量发生变化</td>
</tr>
<tr>
<td>android.intent.action.INPUT_METHOD_CHANGED</td>
<td>系统输入法发生变化</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_CONNECTED</td>
<td>外部电源连接</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_DISCONNECTED</td>
<td>外部电源断开连接</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STARTED</td>
<td>系统开始休眠</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STOPPED</td>
<td>系统停止休眠</td>
</tr>
<tr>
<td>android.intent.action.WALLPAPER_CHANGED</td>
<td>壁纸发生变化</td>
</tr>
<tr>
<td>android.intent.action.HEADSET_PLUG</td>
<td>插入耳机</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_UNMOUNTED</td>
<td>卸载外部介质</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_MOUNTED</td>
<td>挂载外部介质</td>
</tr>
<tr>
<td>android.os.action.POWER_SAVE_MODE_CHANGED</td>
<td>省电模式开启</td>
</tr>
</tbody></table>
<h4 id="强制停止应用"><a href="#强制停止应用" class="headerlink" title="强制停止应用"></a>强制停止应用</h4><p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am force-stop &lt;packagename&gt;</span><br></pre></td></tr></table></figure>

<p>命令示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am force-stop cn.artaris.demo</span><br></pre></td></tr></table></figure>
<p>表示停止 Demo 的一切进程与服务。</p>
<h3 id="设备操作"><a href="#设备操作" class="headerlink" title="设备操作"></a>设备操作</h3><h4 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h4><p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb exec-out screencap -p &gt; sc.png</span><br></pre></td></tr></table></figure>
<p>如果该命令不奏效，可分两步，先使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p /sdcard/screenshoot.png</span><br></pre></td></tr></table></figure>
<p>命令将截图保存到设备中，再使用<code>adb pull</code>导出到电脑。</p>
<h4 id="录屏"><a href="#录屏" class="headerlink" title="录屏"></a>录屏</h4><p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell screenrecord /sdcard/screenrecord.mp4</span><br></pre></td></tr></table></figure>
<p>需要停止时按 <kbd>Ctrl+C</kbd>，默认录制时间和最长录制时间都是 180 秒。<br>再使用<code>adb pull</code>导出到电脑。<br>可以附加以下参数，确定录屏的参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>–size WIDTHxHEIGHT</td>
<td>视频的尺寸，比如 <code>1280x720</code>，默认是屏幕分辨率。</td>
</tr>
<tr>
<td>–bit-rate RATE</td>
<td>视频的比特率，默认是 4Mbps。</td>
</tr>
<tr>
<td>–time-limit TIME</td>
<td>录制时长，单位秒。</td>
</tr>
<tr>
<td>–verbose</td>
<td>输出更多信息。</td>
</tr>
</tbody></table>
<h4 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h4><p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot</span><br></pre></td></tr></table></figure>
<h4 id="压力测试-Monkey"><a href="#压力测试-Monkey" class="headerlink" title="压力测试 Monkey"></a>压力测试 Monkey</h4><p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。</p>
<p>简单用法：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell monkey -p &lt;packagename&gt; -v 500</span><br></pre></td></tr></table></figure>

<p>表示向 <code>&lt;packagename&gt;</code> 指定的应用程序发送 500 个伪随机事件。</p>
<p>Monkey 的详细用法参考 <a href="https://developer.android.com/studio/test/monkey.html">Monkey</a>。</p>
<h4 id="修改分辨率"><a href="#修改分辨率" class="headerlink" title="修改分辨率"></a>修改分辨率</h4><p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell wm size 960x540</span><br></pre></td></tr></table></figure>

<p>表示将分辨率修改为 960px * 540px。</p>
<p>恢复原分辨率命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell wm size reset</span><br></pre></td></tr></table></figure>

<h2 id="Log日志查看"><a href="#Log日志查看" class="headerlink" title="Log日志查看"></a>Log日志查看</h2><p>Android 的日志输出到 &#x2F;dev&#x2F;log。查看命令为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ...</span><br></pre></td></tr></table></figure>
<p>具体用法如下：</p>
<h3 id="过滤日志输出"><a href="#过滤日志输出" class="headerlink" title="过滤日志输出"></a>过滤日志输出</h3><h3 id="按级别过滤日志"><a href="#按级别过滤日志" class="headerlink" title="按级别过滤日志"></a>按级别过滤日志</h3><p>Android 的日志分为如下几个优先级，我们在 Android Studio 的Logcat 选项卡中也可以过滤查看，含义如下</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>V</td>
<td>Verbose</td>
</tr>
<tr>
<td>D</td>
<td>Debug</td>
</tr>
<tr>
<td>I</td>
<td>Info</td>
</tr>
<tr>
<td>W</td>
<td>Warning</td>
</tr>
<tr>
<td>E</td>
<td>Error</td>
</tr>
<tr>
<td>F</td>
<td>Fatal</td>
</tr>
<tr>
<td>S</td>
<td>Silent（啥也不输出）</td>
</tr>
</tbody></table>
<p>按某级别过滤日志则会将该级别及以上的日志全部输出。<br>eg.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat *:W</span><br></pre></td></tr></table></figure>
<p>会将<code>Warning</code>、<code>Warning</code>、<code>Warning</code>和<code>Silent</code>日志输出。<br>（<strong>注：</strong> 在 macOS 下需要给 <code>*:W</code> 这样以 <code>*</code> 作为 tag 的参数加双引号，如 <code>adb logcat &quot;*:W&quot;</code>，不然会报错 <code>no matches found: *:W</code>。）</p>
<h3 id="按Tag过滤日志"><a href="#按Tag过滤日志" class="headerlink" title="按Tag过滤日志"></a>按Tag过滤日志</h3><p><code>&lt;filter-spec&gt;</code> 可以由多个 <code>&lt;tag&gt;[:priority]</code> 组成。</p>
<p>比如，命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat MainActivity:I DemoApp:D *:S</span><br></pre></td></tr></table></figure>

<p>表示输出 tag <code>MainActivity</code> 的 Info 以上级别日志，输出 tag <code>DemoApp</code> 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。</p>
<h2 id="ADB-Shell-相关命令"><a href="#ADB-Shell-相关命令" class="headerlink" title="ADB Shell 相关命令"></a>ADB Shell 相关命令</h2><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell ps</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER     PID   PPID  VSIZE  RSS     WCHAN    PC        NAME</span><br><span class="line">root      1     0     8904   788   ffffffff 00000000 S /init</span><br><span class="line">root      2     0     0      0     ffffffff 00000000 S kthreadd</span><br><span class="line">...</span><br><span class="line">u0_a71    7779  5926  1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classic</span><br><span class="line">u0_a58    7963  5926  1561916 59568 ffffffff 00000000 S cn.artaris.demo</span><br><span class="line">...</span><br><span class="line">shell     8750  217   10640  740   00000000 b6f28340 R ps</span><br></pre></td></tr></table></figure>
<p>各列含义如下：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>USER</td>
<td>所属用户</td>
</tr>
<tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PPID</td>
<td>父进程 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody></table>
<p>下载地址<br><a href="http://gofile.me/3TjWz/EF4mgGZBZ">Platform-Tools</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 线程池的使用</title>
    <url>/Android/Android%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>当我在 Android Studio 中使用如下方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // do sth.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>创造线程时，编译器会报告如下警告：<br><img src="http://img.artaris.cn/android_thread/thread_warning.png"><br>带着这些疑问，让我去学习了一下直接创造线程有什么缺点，及线程池的优点和使用。</p>
<span id="more"></span>

<h3 id="使用new-Thread-创造显式线程的缺点"><a href="#使用new-Thread-创造显式线程的缺点" class="headerlink" title="使用new Thread()创造显式线程的缺点"></a>使用<code>new Thread()</code>创造显式线程的缺点</h3><ul>
<li>在大量任务都在创建线程时，会频繁创建线程，而后这些线程使用完成之后又会被收回，导致频繁的GC，这种情况在多个列表 item 异步加载时极为常见;</li>
<li>多个线程之间互相竞争，缺乏统一的管理，降低了程序的运行效率，甚至卡顿；</li>
<li>当显式线程需要停止时，必须要保留每个线程的实例对象，在多个列表 item 异步加载时管理不便；</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>使用线程池可以给我们带来很多好处，首先通过线程池中线程的重用，减少创建和销毁线程的性能开销。其次，能控制线程池中的并发数，否则会因为大量的线程争夺 CPU 资源造成阻塞。最后，线程池能够对线程进行管理，比如使用 ScheduledThreadPool 来设置延迟N秒后执行任务，并且每隔 M 秒循环执行一次。</p>
<p>Android中常用的线程池都是通过对 ThreadPoolExecutor 进行不同配置来实现的，那么我们今天就从这这个 ThreadPoolExecutor 来开始吧！</p>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>ThreadPoolExecutor 的构造方法中各个参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>corePoolSize</code>:线程池中核心线程的数量;</li>
<li><code>maximumPoolSize</code>:线程池中最大线程数量;</li>
<li><code>keepAliveTime</code>:非核心线程的超时时长。当系统中非核心线程闲置时间超过keepAliveTime之后，则会被回收。如果ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，则该参数也表示核心线程的超时时长;</li>
<li><code>unit</code>:非核心线程的超时时长参数的单位。有纳秒、微秒、毫秒、秒、分、时、天等.eg.<code>TimeUnit.SECONDS</code>、<code>TimeUnit.MILLISECONDS</code>;</li>
<li><code>workQueue</code>:线程池中的任务队列。该队列主要用来存储已经被提交但是尚未执行的任务。存储在这里的任务是由ThreadPoolExecutor的execute方法提交来的。workQueue 是一个 BlockingQueue 类型，BlockingQueue 是一个特殊的队列，当我们从 BlockingQueue 中取数据时，如果 BlockingQueue 是空的，则取数据的操作会进入到阻塞状态，当 BlockingQueue 中有了新数据时，这个取数据的操作又会被重新唤醒。同理，如果 BlockingQueue 中的数据已经满了，往 BlockingQueue 中存数据的操作又会进入阻塞状态，直到 BlockingQueue 中又有新的空间，存数据的操作又会被冲洗唤醒。<br>BlockingQueue 常用的实现类如下几种：</li>
</ul>
<ol>
<li><p><code>ArrayBlockingQueue</code>:这个表示一个规定了大小的 BlockingQueue ， ArrayBlockingQueue 的构造函数接受一个 int 类型的数据，该数据表示 BlockingQueue 的大小，存储在 ArrayBlockingQueue 中的元素按照 FIFO （先进先出）的方式来进行存取。</p>
</li>
<li><p><code>LinkedBlockingQueue</code>:这个表示一个大小不确定的 BlockingQueue ，在 LinkedBlockingQueue 的构造方法中可以传一个int类型的数据，这样创建出来的 LinkedBlockingQueue 是有大小的，也可以不传，不传的话， LinkedBlockingQueue 的大小就为 Integer.MAX_VALUE，源码如下：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a &#123;@code LinkedBlockingQueue&#125; with a capacity of</span><br><span class="line"> * &#123;@link Integer#MAX_VALUE&#125;.</span><br><span class="line"> */</span><br><span class="line">public LinkedBlockingQueue() &#123;</span><br><span class="line">    this(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Creates a &#123;@code LinkedBlockingQueue&#125; with the given (fixed) capacity.</span><br><span class="line"> *</span><br><span class="line"> * @param capacity the capacity of this queue</span><br><span class="line"> * @throws IllegalArgumentException if &#123;@code capacity&#125; is not greater</span><br><span class="line"> *         than zero</span><br><span class="line"> */</span><br><span class="line">public LinkedBlockingQueue(int capacity) &#123;</span><br><span class="line">    if (capacity &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">    this.capacity = capacity;</span><br><span class="line">    last = head = new Node&lt;E&gt;(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><code>PriorityBlockingQueue</code>:这个队列和LinkedBlockingQueue类似，不同的是PriorityBlockingQueue中的元素不是按照FIFO来排序的，而是按照元素的Comparator来决定存取顺序的（这个功能也反映了存入PriorityBlockingQueue中的数据必须实现了Comparator接口）。</p>
</li>
<li><p><code>SynchronousQueue</code>:这个是同步Queue，属于线程安全的BlockingQueue的一种，在SynchronousQueue中，生产者线程的插入操作必须要等待消费者线程的移除操作，Synchronous内部没有数据缓存空间，因此我们无法对SynchronousQueue进行读取或者遍历其中的数据，元素只有在你试图取走的时候才有可能存在。我们可以理解为生产者和消费者互相等待，等到对方之后然后再一起离开。</p>
</li>
</ol>
<ul>
<li><p><code>threadFactory</code>:为线程池提供创建新线程的功能，这个我们一般使用默认即可</p>
</li>
<li><p><code>handler</code>:拒绝策略。当线程无法执行新任务时（一般是由于线程池中的线程数量已经达到最大数或者线程池关闭导致的），默认情况下，当线程池无法处理新线程时，会抛出一个RejectedExecutionException。<br>默认如下:</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static class AbortPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Creates an &#123;@code AbortPolicy&#125;.</span><br><span class="line">     */</span><br><span class="line">    public AbortPolicy() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Always throws RejectedExecutionException.</span><br><span class="line">     *</span><br><span class="line">     * @param r the runnable task requested to be executed</span><br><span class="line">     * @param e the executor attempting to execute this task</span><br><span class="line">     * @throws RejectedExecutionException always</span><br><span class="line">     */</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</span><br><span class="line">                                             &quot; rejected from &quot; +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上则是线程池的构造参数的解释。</p>
<p>那么对于核心线程数和最大线程数，可以参考<code>AsyncTask</code>，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123;</span><br><span class="line">    private static final String LOG_TAG = &quot;AsyncTask&quot;;</span><br><span class="line"></span><br><span class="line">    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    // We want at least 2 threads and at most 4 threads in the core pool,</span><br><span class="line">    // preferring to have 1 less than the CPU count to avoid saturating</span><br><span class="line">    // the CPU with background work</span><br><span class="line">    private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));</span><br><span class="line">    private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;</span><br><span class="line">    private static final int KEEP_ALIVE_SECONDS = 30;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</span><br><span class="line">            new LinkedBlockingQueue&lt;Runnable&gt;(128);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * An &#123;@link Executor&#125; that can be used to execute tasks in parallel.</span><br><span class="line">     */</span><br><span class="line">    public static final Executor THREAD_POOL_EXECUTOR;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class="line">                sPoolWorkQueue, sThreadFactory);</span><br><span class="line">        threadPoolExecutor.allowCoreThreadTimeOut(true);</span><br><span class="line">        THREAD_POOL_EXECUTOR = threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>核心线程数为手机 CPU 数 +1（ CPU 数量获取方式<code>Runtime.getRuntime().availableProcessors()</code>），最大线程数为手机 CPU 数 × 2 + 1，线程队列的大小为 128</p>
<h4 id="ThreadPoolExecutor-的执行规则"><a href="#ThreadPoolExecutor-的执行规则" class="headerlink" title="ThreadPoolExecutor 的执行规则"></a>ThreadPoolExecutor 的执行规则</h4><p>当任务提交到线程池中以后，则会按照一下规则进行处理：</p>
<ol>
<li><p>execute 一个线程之后，如果线程池中的线程数未达到核心线程数，则会立马启用一个核心线程去执行；</p>
</li>
<li><p>execute 一个线程之后，如果线程池中的线程数已经达到核心线程数，且 workQueue 未满，则将新线程放入 workQueue 中等待执行；</p>
</li>
<li><p>execute 一个线程之后，如果线程池中的线程数已经达到核心线程数但未超过非核心线程数，且workQueue已满，则开启一个非核心线程来执行任务；</p>
</li>
<li><p>execute 一个线程之后，如果线程池中的线程数已经超过非核心线程数，则拒绝执行该任务；</p>
</li>
</ol>
<h4 id="系统配置的-ThreadPoolExecutor"><a href="#系统配置的-ThreadPoolExecutor" class="headerlink" title="系统配置的 ThreadPoolExecutor"></a>系统配置的 ThreadPoolExecutor</h4><ul>
<li>FixedThreadPool<br>FixedThreadPool是一个核心线程数量固定的线程池，创建方式如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);  </span><br><span class="line"></span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到核心线程数和最大线程数一样，说明在 FixedThreadPool 中没有非核心线程，所有的线程都是核心线程，且线程的超时时间为0，说明核心线程即使在没有任务可执行的时候也不会被销毁（这样可让 FixedThreadPool 更快速的响应请求），最后的线程队列是一个 LinkedBlockingQueue ，但是 LinkedBlockingQueue 却没有参数，这说明线程队列的大小为 Integer.MAX_VALUE（2的31次方减1），OK，看完参数，我们大概也就知道了 FixedThreadPool 的工作特点了，当所有的核心线程都在执行任务的时候，新的任务只能进入线程队列中进行等待，直到有线程被空闲出来.</p>
<ul>
<li>SingleThreadExecutor</li>
</ul>
<p>SingleThreadExecutor 和 FixedThreadPool 很像，不同的就是 SingleThreadExecutor 的核心线程数只有 1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 SingleThreadExecutor 的一个最大好处就是可以避免我们去处理线程同步问题，其实如果我们把 FixedThreadPool 的参数传个1，效果就和SingleThreadExecutor一致了.</p>
<ul>
<li>CachedThreadPool</li>
</ul>
<p>CachedTreadPool一个最大的优势是它可以根据程序的运行情况自动来调整线程池中的线程数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到， CachedThreadPool 中是没有核心线程的，但是它的最大线程数却为 Integer.MAX_VALUE ，另外，它是有线程超时机制的，超时时间为60秒，这里它使用了 SynchronousQueue 作为线程队列， SynchronousQueue 的特点上文已经说过了，这里不再赘述。那么我们提交到 CachedThreadPool 消息队列中的任务在执行的过程中有什么特点呢？由于最大线程数为无限大，所以每当我们添加一个新任务进来的时候，如果线程池中有空闲的线程，则由该空闲的线程执行新任务，如果没有空闲线程，则创建新线程来执行任务。根据 CachedThreadPool 的特点，我们可以在有大量任务请求的时候使用 CachedThreadPool ，因为当 CachedThreadPool 中没有新任务的时候，它里边所有的线程都会因为超时而被终止。</p>
<ul>
<li>ScheduledThreadPool</li>
</ul>
<p>ScheduledThreadPool是一个具有定时定期执行任务功能的线程池，源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">    super(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，它的核心线程数量是固定的（我们在构造的时候传入的），但是非核心线程是无穷大，当非核心线程闲置时，则会被立即回收。</p>
<p>使用ScheduledThreadPool时，我们可以通过如下几个方法来添加任务：</p>
<ol>
<li>延迟启动任务</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ScheduledFuture&lt;?&gt; schedule(Runnable command,long delay, TimeUnit unit);</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>延迟定时执行循环任务</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ScheduledFuture&lt;?&gt; schedule(Runnable command,long delay, TimeUnit unit);</span><br></pre></td></tr></table></figure>

<p>延迟 initialDelay 秒后每个 period 秒执行一次任务。</p>
<ol start="3">
<li>延迟执行任务</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                 long initialDelay,</span><br><span class="line">                                                 long delay,</span><br><span class="line">                                                 TimeUnit unit)</span><br></pre></td></tr></table></figure>

<p>第一次延迟 initialDelay 秒，以后每次延迟 delay 秒执行一个任务。</p>
<h4 id="ThreadPoolExecutor-其他常用功能"><a href="#ThreadPoolExecutor-其他常用功能" class="headerlink" title="ThreadPoolExecutor 其他常用功能"></a>ThreadPoolExecutor 其他常用功能</h4><ul>
<li><code>shutDown()</code> 关闭线程池，不影响已经提交的任务;</li>
<li><code>shutDownNow()</code> 关闭线程池，并尝试去终止正在执行的线程;</li>
<li><code>allowCoreThreadTimeOut(boolean value)</code> 允许核心线程闲置超时时被回收</li>
<li><code>submit()</code></li>
<li>ThreadPoolExecutor 执行任务回调：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void beforeExecute(Thread t, Runnable r) &#123;</span><br><span class="line">    super.beforeExecute(t, r);</span><br><span class="line">    Log.d(TAG, &quot;beforeExecute: 开始执行任务！&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void afterExecute(Runnable r, Throwable t) &#123;</span><br><span class="line">    super.afterExecute(r, t);</span><br><span class="line">    Log.d(TAG, &quot;beforeExecute: 任务执行结束！&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void terminated() &#123;</span><br><span class="line">    super.terminated();</span><br><span class="line">    //当调用shutDown()或者shutDownNow()时会触发该方法  </span><br><span class="line">    Log.d(TAG, &quot;terminated: 线程池关闭！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当线程池中的任务被执行的时候会回调此方法。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 知识整理(一、Java 基础知识)</title>
    <url>/%E9%9D%A2%E8%AF%95/Java/Android-%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E4%B8%80%E3%80%81Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>一些 Java 基础知识的问题。</p>
<span id="more"></span>

<h2 id="Java-中-x3D-x3D-和-equals-和-hashCode-的区别"><a href="#Java-中-x3D-x3D-和-equals-和-hashCode-的区别" class="headerlink" title="Java 中 &#x3D;&#x3D; 和 equals() 和 hashCode() 的区别"></a>Java 中 &#x3D;&#x3D; 和 equals() 和 hashCode() 的区别</h2><ul>
<li>对于基本数据类型，&#x3D;&#x3D; 是比较这两个基本数据类型的值</li>
<li>对于对象，&#x3D;&#x3D; 是比较两个对象的内存地址。equals() 是所有对象 Object 基类的一个方法，默认实现是比较两个对象的内存地址，在对于 Java 的有些类中重写了这个方法，内部使用了不同的逻辑，如 String 类的 equals() 方法是比较两个字符串是否相同。</li>
<li>hashCode()是计算一个对象的 hash 值，用在 HashMap 等对比冲突的地方<ul>
<li>相等（相同）的对象必须具有相等的哈希码（或者散列码）。</li>
<li>如果两个对象的hashCode相同，它们并不一定相同。</li>
</ul>
</li>
</ul>
<blockquote>
<p>扩展：Integer 等包装类，会有一个128大小的自有缓冲区，当一个新的 Integer 被创建时，它会先去缓冲区寻找，找到值会直接赋值给这个对象，所以两个 Integer 的值在这个缓冲区是，它们的 &#x3D;&#x3D; 方法虽然是比较它们的内存地址，但是返回是 true。</p>
<p>String 对象比较特殊，是不可变的字符串，当有新的对象创建使用 <code>String s = &quot;Hello World.&quot;;</code>时，会去缓冲区去找是否有相同的字符串，如果有就直接这个内存地址赋给这个对象。但是使用<code>String s = new String(&quot;Hello World.&quot;);</code>会直接开辟一块新的内存地址。</p>
</blockquote>
<h2 id="int、char、long各占多少字节数"><a href="#int、char、long各占多少字节数" class="headerlink" title="int、char、long各占多少字节数"></a>int、char、long各占多少字节数</h2><p><img src="http://img.artaris.cn/2019-03-19-15508221786523.jpg"></p>
<h2 id="int-与-Integer-的区别"><a href="#int-与-Integer-的区别" class="headerlink" title="int 与 Integer 的区别"></a>int 与 Integer 的区别</h2><p>int 是 Java 的基本数据类型，具体请看 <a href="http://artaris.cn/Java/int-%E4%B8%8E-Integer/">int 与 Integer</a></p>
<h2 id="谈谈对-Java-多态的理解"><a href="#谈谈对-Java-多态的理解" class="headerlink" title="谈谈对 Java 多态的理解"></a>谈谈对 Java 多态的理解</h2><p>Java 面向对象的三大特性：继承、封装、多态。</p>
<ul>
<li>封装：封装私有变量，创建公共方法供外部调用，实现了访问控制，让客户端程序员无法触及不该触及的部分，创建者通过内外分离不担心自己的修改影响了外部调用。</li>
<li>继承：</li>
<li>多态：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。</li>
</ul>
<p>实现多态的技术成为：动态绑定</p>
<h2 id="String、StringBuffer、StringBuilder区别"><a href="#String、StringBuffer、StringBuilder区别" class="headerlink" title="String、StringBuffer、StringBuilder区别"></a>String、StringBuffer、StringBuilder区别</h2><ul>
<li>String 字符串常量<br>  是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String</li>
<li>StringBuilder 字符串变量（非线程安全）<br>  可变对象</li>
<li>StringBuffer 字符串变量（线程安全）<br>  <code>append()</code>相比起 StringBuilder 来说多了一个 synchronized 关键字，会执行线程同步。</li>
</ul>
<blockquote>
<p>为啥 Java 中 String 要设计成不可变的对象</p>
<ol>
<li>字符串常量池的需要：当创建一个String对象时,假如此字符串值已经存在于常量池中,则不会创建一个新的对象,而是引用已经存在的对象。</li>
<li>安全性：String被许多的Java类(库)用来当做参数或者key,假若String不是固定不变的,将会引起各种安全隐患,容易引起中间篡改。</li>
<li>允许String对象缓存HashCode：字符串不变性保证了hash码的唯一性,因此可以放心地进行缓存.这也是一种性能优化手段,意味着不必每次都去计算新的哈希码.</li>
</ol>
</blockquote>
<h2 id="什么是内部类？内部类的作用"><a href="#什么是内部类？内部类的作用" class="headerlink" title="什么是内部类？内部类的作用"></a>什么是内部类？内部类的作用</h2><p>内部类是在类中声明的一个类</p>
<p>内部类的 new 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OuterClass outerObject = new OuterClass();</span><br><span class="line">outerClass.InnerClass innerObject = outerObject.new InnerClass();</span><br></pre></td></tr></table></figure>

<h3 id="内部类的性质"><a href="#内部类的性质" class="headerlink" title="内部类的性质"></a>内部类的性质</h3><ul>
<li>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li>
</ul>
<blockquote>
<p>当外部类的对象创建了一个内部类的对象时，内部类对象必定会秘密捕获一个指向外部类对象的引用，然后访问外部类的成员时，就是用那个引用来选择外围类的成员的。</p>
</blockquote>
<ul>
<li>内部类可以直接访问外部类的属性和方法</li>
<li>每个内部类都能独立地继承一个（接口的）实现</li>
<li>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li>
<li>创建内部类对象的时刻必须先创建了外部类之后才能创建，但之后并不依赖于外围类对象的创建。</li>
<li>成员内部类中不能存在任何 static 的变量和方法，(因为1、static类型的属性和方法，在类加载的时候就会存在于内存中。2、要使用某个类的static属性或者方法，那么这个类必须要加载到jvm中。内部类在外部类创建时没有加载，因此不能使用其 static 属性和方法)，除非内部类是 static 类。</li>
</ul>
<blockquote>
<p>此种不能同时存在的类均与 Java 的生命周期相关，内部类的生命周期是从外内部类创建之后才有的，但是静态属性是随着类的加载的，这是相互矛盾的。当内部类设为静态类时生命周期就一致了</p>
</blockquote>
<p>静态内部类</p>
<ul>
<li>静态内部类：</li>
<li>它的创建是不需要依赖于外围类的。</li>
<li>它不能使用任何外围类的非static成员变量和方法。</li>
</ul>
<p>匿名内部类</p>
<ul>
<li>可以简化代码。</li>
<li>匿名内部类是没有访问修饰符的。</li>
<li>匿名内部类是没有构造方法的。</li>
<li>匿名内部类中不能存在任何静态成员或方法。</li>
</ul>
<h3 id="内部类的作用"><a href="#内部类的作用" class="headerlink" title="内部类的作用"></a>内部类的作用</h3><ul>
<li>使用内部类可以间接实现多重继承</li>
<li>提供了更好的封装，只有外部类能访问内部类，其他类不能直接访问内部类（即是内部类是public 的也只能通过其承载的外部类访问）</li>
</ul>
<h2 id="抽象类和接口区别"><a href="#抽象类和接口区别" class="headerlink" title="抽象类和接口区别"></a>抽象类和接口区别</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>抽象类可以有自己的方法实现：接口只能定义方法，是抽象的。</li>
<li>抽象类中子类使用 extends 来继承抽象类，如果子类不是抽象类，它需要实现所有的抽象方法：接口中子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</li>
<li>抽象类可以有构造器：</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">抽象类</th>
<th align="center">接口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">继承</td>
<td align="center">子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td align="center">子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td align="center">构造器</td>
<td align="center">抽象类可以有构造器</td>
<td align="center">接口不能有构造器</td>
</tr>
<tr>
<td align="center">与实体Java类的区别</td>
<td align="center">除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td>
<td align="center">接口是完全不同的类型</td>
</tr>
<tr>
<td align="center">访问修饰符</td>
<td align="center">抽象方法可以有public、protected和default这些修饰符</td>
<td align="center">接口方法默认修饰符是public。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td align="center">main方法</td>
<td align="center">抽象方法可以有main方法并且我们可以运行它</td>
<td align="center">接口没有main方法，因此我们不能运行它。</td>
</tr>
<tr>
<td align="center">多继承</td>
<td align="center">抽象方法可以继承一个类和实现多个接口</td>
<td align="center">接口只可以继承一个或多个其它接口</td>
</tr>
<tr>
<td align="center">速度</td>
<td align="center">它比接口速度要快</td>
<td align="center">接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
<tr>
<td align="center">添加新方法</td>
<td align="center">如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td>
<td align="center">如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
<tr>
<td align="center">默认的方法实现</td>
<td align="center">它可以有默认的方法实现</td>
<td align="center">接口完全是抽象的。它根本不存在方法的实现</td>
</tr>
</tbody></table>
<h2 id="抽象类的意义"><a href="#抽象类的意义" class="headerlink" title="抽象类的意义"></a>抽象类的意义</h2><ol>
<li>为子类提供一个公共的类型；</li>
<li>封装子类中重复内容（成员变量和方法）；</li>
<li>定义有抽象方法，子类虽然有不同的实现，但该方法的定义是一致的。</li>
</ol>
<h2 id="抽象类与接口的应用场景"><a href="#抽象类与接口的应用场景" class="headerlink" title="抽象类与接口的应用场景"></a>抽象类与接口的应用场景</h2><h3 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>如果想定义一些公共方法并给其中一些方法默认实现，使用抽象类；</li>
<li>抽象类是用来捕捉子类的通用特性的，一般作为类的基类，在其中添加了一些方法不回影响到所有子类（子类不需要全部覆盖）；</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>多重继承只能使用接口；</li>
<li>作为两个类的通信协议，传递一些信息或者数据时，定义接口；</li>
</ul>
<h2 id="抽象类是否可以没有方法和属性？"><a href="#抽象类是否可以没有方法和属性？" class="headerlink" title="抽象类是否可以没有方法和属性？"></a>抽象类是否可以没有方法和属性？</h2><p>可以没有方法和属性。<br>抽象类的作用在于子类对其的继承和实现，也就是多态；而没有抽象方法的抽象类的存在价值在于：<strong>实例化了没有意义，因为类已经定义好了，不能改变其中的方法体，但是实例化出来的对象却满足不了要求，只有继承并重写了他的子类才能满足要求。所以才把它定义为没有抽象方法的抽象类</strong></p>
<ul>
<li>抽象类专用于派生出子类，子类必须实现抽象类所声明的抽象方法，否则，子类仍是抽象类。</li>
<li>包含抽象方法的类一定是抽象类，但抽象类中的方法不一定是抽象方法。</li>
</ul>
<h2 id="接口的意义"><a href="#接口的意义" class="headerlink" title="接口的意义"></a>接口的意义</h2><ul>
<li>接口体现了抽象的特点，抽象的定义就是抽取像的部分，可以提取一些类的共性。</li>
<li>接口并不负责具体的操作，具体的操作是由接口的实现类完成的</li>
<li>接口具有简单，规范性：实现相同接口的类可以替换，他们遵循相同的规范，实现了相同的功能。</li>
<li>接口具维护、拓展性：在之后代码中可以随时替换类，只要这些类实现了相同的接口，接口具有规范性</li>
<li>接口具有安全、严密性：在两个类进行通信的时候，并不公开全部的内部代码，只要通过接口进行通信即可</li>
<li></li>
</ul>
<h2 id="泛型中extends和super的区别"><a href="#泛型中extends和super的区别" class="headerlink" title="泛型中extends和super的区别"></a>泛型中extends和super的区别</h2><p>简单来说，&lt;? super T&gt;表示包括T在内的任何T的父类，&lt;? extends T&gt;表示包括T在内的任何T的子类。</p>
<ul>
<li><? extends T> 只能用于方法返回，告诉编译器此返参的类型的最小继承边界为T，T和T的父类都能接收，但是入参类型无法确定，只能接受null的传入</li>
<li><? super T>只能用于限定方法入参，告诉编译器入参只能是T或其子类型，而返参只能用Object类接收</li>
<li>? 既不能用于入参也不能用于返参</li>
</ul>
<h2 id="父类的静态方法能否被子类重写"><a href="#父类的静态方法能否被子类重写" class="headerlink" title="父类的静态方法能否被子类重写"></a>父类的静态方法能否被子类重写</h2><p>不可以。<br>**所谓静态就是指：在编译之后所分配的内存会一直存在（不会被回收），直到程序退出内存才会释放这个空间。<br>**<br>静态方法只与类有关，不与实例有关，重写只适用于实例方法，不适用于静态方法。</p>
<p>因为静态方法是程序一运行就已经分配好了内存地址，而且该地址是固定的，所有引用到该方法的对象（父类或者子类）所指向的始终是同一个内存地址中的数据，即该静态方法。如果子类定义了相同名称的静态方法，只会新增一个内存地址，并不会重写。</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>进程和线程都是一个时间段的描述，是CPU工作时间段的描述。</p>
<p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>
<p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.<br>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.<br>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p>
<p>进程包括自己独立的地址空间、堆栈和局部变量，线程共享进程的地址空间、堆栈和局部变量。<br>进程切换的时候需要切换上下文，耗费资源较大。</p>
<h2 id="final，finally，finalize的区别"><a href="#final，finally，finalize的区别" class="headerlink" title="final，finally，finalize的区别"></a>final，finally，finalize的区别</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>用于申明属性，方法和类，表示属性不可变，方法不可以被覆盖，类不可以被继承。</p>
<ul>
<li>变量<br>  final修饰变量表示该变量是不可变的。当指向一个对象时：指向的内存地址是不变的，但是被指的内存地址中的类是可以改变的。</li>
<li>方法<br>  final修饰方法时表示该方法是不能被子类重写的。</li>
<li>类<br>  final修饰类时表示该类是不能被继承的，由于java的单继承关系，所以该类是继承关系链中的终端。</li>
</ul>
<p>接口中声明的所有变量都是final的；</p>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>是异常处理语句结构中，表示总是执行的部分。　　<br>具体请看 <a href="http://artaris.cn/Java/try%E3%80%81catch%E3%80%81finally%E3%80%81throw%E5%92%8Cthrows/">try、catch、finally、throw和throws</a></p>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><p>表示是object类一个方法，在垃圾回收机制中执行的时候会被调用被回收对象的方法。允许回收此前未回收的内存垃圾。所有object都继承了 <code>finalize()</code> 方法</p>
<h2 id="序列化的方式"><a href="#序列化的方式" class="headerlink" title="序列化的方式"></a>序列化的方式</h2><p>将序列化的数据实现 Serializable&#x2F;Parcelable 接口，通过 Intent.putExtra 或者 Binder 传递数据。</p>
<h2 id="Serializable-和-Parcelable-的区别"><a href="#Serializable-和-Parcelable-的区别" class="headerlink" title="Serializable 和 Parcelable 的区别"></a>Serializable 和 Parcelable 的区别</h2><h3 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h3><p>实现非常简单，出了需要继承 Serializable 接口外只要创建一个 serialVersionUID 属性就好。</p>
<h4 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h4><p>serialVersionUID 在运行时唯一标识了一个可序列化的类。一个类序列化时，运行时会保存它的版本号，然后在反序列化时检查你要反序列化成的对象版本号是否一致，不一致的话就会报错：InvalidClassException。</p>
<h4 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h4><p>Serializable 的序列化与反序列化分别通过 ObjectOutputStream 和 ObjectInputStream 进行，实例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 序列化对象</span><br><span class="line"> *</span><br><span class="line"> * @param obj</span><br><span class="line"> * @param path</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">synchronized public static boolean saveObject(Object obj, String path) &#123;</span><br><span class="line">    if (obj == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    ObjectOutputStream oos = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        oos = new ObjectOutputStream(new FileOutputStream(path));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">        oos.close();</span><br><span class="line">        return true;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (oos != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 反序列化对象</span><br><span class="line"> *</span><br><span class="line"> * @param path</span><br><span class="line"> * @param &lt;T&gt;</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&quot;unchecked &quot;)</span><br><span class="line">synchronized public static &lt;T&gt; T readObject(String path) &#123;</span><br><span class="line">    ObjectInputStream ojs = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        ojs = new ObjectInputStream(new FileInputStream(path));</span><br><span class="line">        return (T) ojs.readObject();</span><br><span class="line">    &#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        close(ojs);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Parcelable-接口"><a href="#Parcelable-接口" class="headerlink" title="Parcelable 接口"></a>Parcelable 接口</h3><p>Parcelable 是 Android 特有的序列化方式<br>实现 Parcelable 的方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ParcelClass implements Parcelable &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public int id;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 系统自动添加，给createFromParcel里面用</span><br><span class="line">     * @param in</span><br><span class="line">     */</span><br><span class="line">    protected ParcelClass(Parcel in) &#123;</span><br><span class="line">        name = in.readString();</span><br><span class="line">        id = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 序列话数据</span><br><span class="line">     * @param dest</span><br><span class="line">     * @param flags</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeInt(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 内容接口描述，默认返回0即可。</span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final Creator&lt;ParcelClass&gt; CREATOR = new Creator&lt;ParcelClass&gt;() &#123;</span><br><span class="line">        /**</span><br><span class="line">         *</span><br><span class="line">         * @param in</span><br><span class="line">         * @return</span><br><span class="line">         * createFromParcel()方法中我们要去读取刚才写出的name和age字段，</span><br><span class="line">         * 并创建一个Person对象进行返回，其中 name 和 id 都是调用Parcel的readXxx()方法读取到的，</span><br><span class="line">         * 注意这里读取的顺序一定要和刚才写出的顺序完全相同。</span><br><span class="line">         * 读取的工作我们利用一个构造函数帮我们完成了</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public ParcelClass createFromParcel(Parcel in) &#123;</span><br><span class="line">            return new ParcelClass(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //供反序列化本类数组时调用的</span><br><span class="line">        @Override</span><br><span class="line">        public ParcelClass[] newArray(int size) &#123;</span><br><span class="line">            return new ParcelClass[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>编码上：</li>
</ul>
<p>Serializable代码量少，写起来方便<br>Parcelable代码多一些</p>
<ul>
<li>效率上：</li>
</ul>
<p>Parcelable的速度比高十倍以上。<br>Serializable 这种方法的缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。</p>
<h2 id="静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"><a href="#静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？" class="headerlink" title="静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"></a>静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</h2><p>可以被继承，不可以被重写。</p>
<ol>
<li>静态方法和属性是属于类的，调用的时候直接通过类名.方法名完成对，不需要继承机制即可以调用。如果子类里面定义了静态方法和属性，那么这时候父类的静态方法或属性称之为”隐藏”。如果你想要调用父类的静态方法和属性，直接通过父类名.方法或变量名完成，至于是否继承一说，子类是有继承静态方法和属性，但是跟实例方法和属性不太一样，存在”隐藏”的这种情况。</li>
<li>多态之所以能够实现依赖于继承、接口和重写、重载（继承和重写最为关键）。有了继承和重写就可以实现父类的引用指向不同子类的对象。重写的功能是：”重写”后子类的优先级要高于父类的优先级，但是“隐藏”是没有这个优先级之分的。</li>
<li>静态属性、静态方法和非静态的属性都可以被继承和隐藏而不能被重写，因此不能实现多态，不能实现父类的引用可以指向不同子类的对象。非静态方法可以被继承和重写，因此可以实现多态。</li>
</ol>
<h2 id="静态内部类的设计意图"><a href="#静态内部类的设计意图" class="headerlink" title="静态内部类的设计意图"></a>静态内部类的设计意图</h2><ul>
<li>它的创建是不需要依赖于外围类的。</li>
<li>它不能使用任何外围类的非static成员变量和方法。</li>
</ul>
<h2 id="成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用"><a href="#成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用" class="headerlink" title="成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用"></a>成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用</h2><p>具体请看 <a href="## 什么是内部类？内部类的作用">内部类</a></p>
<h2 id="谈谈对kotlin的理解"><a href="#谈谈对kotlin的理解" class="headerlink" title="谈谈对kotlin的理解"></a>谈谈对kotlin的理解</h2><p>&#x2F;&#x2F;TODO</p>
<h2 id="闭包和局部内部类的区别"><a href="#闭包和局部内部类的区别" class="headerlink" title="闭包和局部内部类的区别"></a>闭包和局部内部类的区别</h2><p>局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p>
<h2 id="String-转换成-integer的方式及原理"><a href="#String-转换成-integer的方式及原理" class="headerlink" title="String 转换成 integer的方式及原理"></a>String 转换成 integer的方式及原理</h2><p>进过一系列判断，最后负着一直加首位的数，再乘以十，最后负的返回原值，正的返回相反数</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Android  7.1 新特性——Shortcuts</title>
    <url>/Android/Android%20%207.1%20%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94Shortcuts/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Android 7.1 （API level25、Build.VERSION_CODES.N_MR1）中加入了新的 API ——Shortcuts，它提供了一种新的快捷访问方式，类似于 iPhone 的 3D Touch （现已加入豪华名称菜单——三维触控），并且这中快捷方式可以被拖拽到桌面上单独放置。</p>
<p><a href="http://img.artaris.cn/shortcuts/ShortcutsDemo.apk">吐泡泡 Shortcuts Demo 下载</a></p>
<span id="more"></span>

<p>如下图所示：</p>
<p><img src="http://img.artaris.cn/shortcuts/img-2.jpg?imageMogr2/thumbnail/!30p"></p>
<h4 id="分类及作用"><a href="#分类及作用" class="headerlink" title="分类及作用"></a>分类及作用</h4><p>Shortcuts 也可以通过静态和动态方式添加。静态的方式可以作为 APP 的一个快捷入口来使用，动态的方式可以作为可变换的选项来使用。</p>
<ul>
<li><p><strong>Static shortcuts</strong>：静态shortcuts是在资源文件中定义的，所以你只能通过升级你的app来更新静态shortcuts的相关信息。</p>
</li>
<li><p><strong>Dynamic shortcuts</strong>：动态shortcuts是通过ShortcutManager相关的API来实现运行时新增、修改、移除shortcuts的。</p>
</li>
</ul>
<h4 id="静态-Shorcuts-Static-shortcuts"><a href="#静态-Shorcuts-Static-shortcuts" class="headerlink" title="静态 Shorcuts(Static shortcuts)"></a>静态 Shorcuts(Static shortcuts)</h4><p>静态 ShortcutsStatic Shortcuts通过在 Manifest 中声明添加。缺点是不可以修改，只能通过应用升级来添加新的静态 Shortcuts。添加主要分为两步：</p>
<p>1 . AndroidManifest.xml 的 Main Launcher 对应的 Activity 内添加 <code>meta-data meta-data name</code> 为<code>android.app.shortcuts</code>，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.MainActivity&quot;&gt;</span><br><span class="line">	&lt;intent-filter&gt;</span><br><span class="line">		&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line">		&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">	&lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">	&lt;meta-data</span><br><span class="line">		android:name=&quot;android.app.shortcuts&quot;</span><br><span class="line">		android:resource=&quot;@xml/shortcuts&quot;/&gt;   </span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>
<p>必须在启动界面对应的 Activity 定义 shortcuts ，<code>android:resource</code>指向了 shortcuts 的资源文件。</p>
<ol start="2">
<li>资源文件中定义具体的 shortcuts<br>res 目录下新建 xml 文件夹，并新建 shortcuts.xml 文件，内容如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;shortcuts xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;shortcut</span><br><span class="line">        android:shortcutId=&quot;settings&quot;</span><br><span class="line">        android:enabled=&quot;true&quot;</span><br><span class="line">        android:icon=&quot;@mipmap/ic_star_border_black_24dp&quot;</span><br><span class="line">        android:shortcutShortLabel=&quot;@string/settings_short_name&quot;</span><br><span class="line">        android:shortcutLongLabel=&quot;@string/settings_long_name&quot;</span><br><span class="line">        android:shortcutDisabledMessage=&quot;@string/settings_disable_msg&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;intent</span><br><span class="line">            android:action=&quot;android.intent.action.VIEW&quot;</span><br><span class="line">            android:targetPackage=&quot;cn.artaris.shortcutsdemo&quot;</span><br><span class="line">            android:targetClass=&quot;cn.artaris.shortcutsdemo.MainActivity&quot; /&gt;</span><br><span class="line">        &lt;categories android:name=&quot;android.shortcut.conversation&quot;/&gt;</span><br><span class="line">    &lt;/shortcut&gt;</span><br><span class="line">&lt;/shortcuts&gt;</span><br></pre></td></tr></table></figure>
<p>以 <code>&lt;shortcuts&gt;</code>元素为根，可以包含多个 shortcut 元素，每个 shortcut 元素表示一个 shortcut。其中不同字段的含义为：</p>
<ul>
<li>shortcutId表示 shortcut 唯一标识符，相同的 shortcutId 会被覆盖。必须字段。</li>
<li>shortcutShortLabel为将 shortcut 拖动到桌面时显示的名字，官方建议不超过 10 个字符，必须字段。</li>
<li>shortcutLongLabel为 shortcut 列表中每个 shortcut 的名字，不宜过长，如果过长或未设置默认会显示 ShortLabel，官方建议不超过 25 个字符。可选字段。</li>
<li>icon为 shortcut 的 icon，在列表展示和拖动到桌面时显示需要，可选字段。</li>
<li>enabled表示 shortcut 是否可用，false 表示禁用。xml 中这个属性几乎没有被设置为 false 的实际场景，具体原因可见<strong>6.7 如何更好的删除(废弃)老的 Shortcut</strong>中介绍。</li>
<li>shortcutDisabledMessage为已固定在桌面的 shortcut 被 Disabled 后点击时的 Toast 提示内容。可选字段。</li>
<li>intent为点击 shortcut 时响应的 Intent，必须字段。这里可以添加多个 Intent，成为一个 Intent 栈，点击会启动最后一个 Intent，在这个 Intent 回退时会启动它前面一个 Intent，相当于自动将所有 Intent 添加到了堆栈。对于先跳转到某个页面，Back 键希望退回主页而不是结束 App 这类场景，多个 Intents 挺实用的。</li>
</ul>
<blockquote>
<p><strong>intent可设置属性包括：</strong><br><code>android:action</code>、<code>android:data</code>、<code>android:mimeType</code>、<code>android:targetClass</code>、<code>android:targetPackage</code>。其中<code>android:action</code>为必须属性。</p>
</blockquote>
<h4 id="动态-Shorcuts-Dynamic-shortcuts"><a href="#动态-Shorcuts-Dynamic-shortcuts" class="headerlink" title="动态 Shorcuts(Dynamic shortcuts)"></a>动态 Shorcuts(Dynamic shortcuts)</h4><p>动态 ShortcutsDynamic Shortcuts 通过 ShortcutManager API 进行操作。可以动态添加、修改、删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N_MR1) &#123;</span><br><span class="line">    /*</span><br><span class="line">    * 获取 ShortcutManager 管理 shortcuts</span><br><span class="line">    */</span><br><span class="line">    mShortcutManager = getSystemService(ShortcutManager.class);</span><br><span class="line">    /*</span><br><span class="line">    * 获取 ShortcutManager 支持的最多 shortcuts 个数</span><br><span class="line">    */</span><br><span class="line">    mMaxShortcutCount = mShortcutManager.getMaxShortcutCountPerActivity();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    new AlertDialog.Builder(mContext)</span><br><span class="line">            .setTitle(getString(R.string.main_dialog_simple_title))</span><br><span class="line">            .setMessage(getString(R.string.main_dialog_simple_message))</span><br><span class="line">            .setNeutralButton(getString(R.string.dialog_confirm), new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                    finish();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建新的 shortcut 的方法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Icon icon = Icon.createWithResource(mContext, R.mipmap.ic_favorite_black_24dp);   Intent intent = new Intent(mContext, ShowShortcutsActivity.class); intent.setAction(Intent.ACTION_VIEW); intent.putExtra(&quot;msg&quot;, singleChoiceItems[itemSelected]);</span><br><span class="line"></span><br><span class="line">ShortcutInfo shortcut = new ShortcutInfo.Builder(mContext, String.valueOf(itemSelected))</span><br><span class="line">        .setShortLabel(singleChoiceItems[itemSelected])</span><br><span class="line">        .setLongLabel(singleChoiceItems[itemSelected])</span><br><span class="line">        .setIcon(icon)</span><br><span class="line">        .setIntent(intent)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<p>添加的方法有：</p>
<ul>
<li><code>setDynamicShortcuts(List&lt;ShortcutInfo&gt;)</code>可以替换并添加所有 shortcut 列表；</li>
<li><code>addDynamicShortcuts(List&lt;ShortcutInfo&gt;)</code>可以添加新的 shortcut 到列表，超过最大个数会报异常；</li>
<li><code>updateShortcuts(List&lt;ShortcutInfo&gt;)</code>可以更新一组 shortcuts；</li>
<li><code>removeDynamicShortcuts(List&lt;ShortcutInfo&gt;)</code>和removeAllDynamicShortcuts() 可以删除部分或所有 shortcuts。</li>
</ul>
<p>ShortcutInfo 的属性与 xml 中定义字段含义一致，shortcutId shortcutShortLabel intent 是必须设置的字段，并且intent必须设置Action。</p>
<h4 id="固定的-Shortcuts-Pinned-Shortcuts"><a href="#固定的-Shortcuts-Pinned-Shortcuts" class="headerlink" title="固定的 Shortcuts(Pinned Shortcuts)"></a>固定的 Shortcuts(Pinned Shortcuts)</h4><p>Pinned Shortcuts 是指将 Shortcut 固定到桌面的功能，如下图所示：<br><img src="http://img.artaris.cn/shortcuts/img-1.jpg?imageMogr2/thumbnail/!30p"><br>由于固定到了桌面，APP 不能再添加、修改、删除这些这些 Shortcut ，只能禁用这些 Shortcut 。即便 App 内删除了某个 Shorcut，对应的已固定到桌面的 Shortcuts 也不会被删除。</p>
<p>可以通过：</p>
<ol>
<li><code>getPinnedShortcuts()</code>得到所有固定的 Shortcuts 的信息。</li>
<li><code>disableShortcuts(List)</code>或<code>disableShortcuts(List, CharSequence)</code>禁用动态的 Shortcuts。</li>
</ol>
<p>对于静态的 Shortcuts 需要在资源文件中设置<code>android:enabled=&quot;false&quot;</code>进行禁用，不过静态 Shortcuts 可直接通过删除达到禁用的效果.</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>动态 Shortcuts 与静态 Shortcuts 区别</li>
</ul>
<ol>
<li>静态 Shortcuts 只能通过升级应用修改，动态 Shortcuts 随时可以修改；</li>
<li>静态 Shortcuts 的 Intent 无法设置 Flag，默认为<code>FLAG_ACTIVITY_NEW_TASK</code>和<code>FLAG_ACTIVITY_CLEAR_TASK Flag</code>，即若应用运行中会清除所有已存在的 Activity。动态 Shortcuts 的 Intent 可以设置 Flag；</li>
<li>静态 Shortcuts 的rank系统默认根据声明顺序设置，动态 Shortcuts 的rank可以通过setRank(int rank)接口主动设置，rank 不能小于 0，值越大表示在 shortcut 列表展示时离 App Icon 越远。静态 Shortcuts 默认比动态 Shortcuts 离 App Icon 更近。</li>
<li>静态 Shortcuts 删除可以直接删除，动态 Shortcuts 建议通过禁用删除；</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>BroadcastReceiver 与 LocalBroadcastReceiver 的比较</title>
    <url>/Android/BroadcastReceiver-%E4%B8%8E-LocalBroadcastReceiver-%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>LocalBroadcastReceiver 和 BroadcastReceiver 均为常用的广播方法。这里比较一下他们之间的区别与使用。</p>
<span id="more"></span>

<h2 id="LocalBroadcastReceiver"><a href="#LocalBroadcastReceiver" class="headerlink" title="LocalBroadcastReceiver"></a>LocalBroadcastReceiver</h2><p>LocalBroadcastReceiver 是本地广播，只能在应用使用和接收。</p>
<ol>
<li>获取一个localBroadcastManager实例</li>
<li>使用localBroadcastManager.sendBroadcast(intent)方法发送广播</li>
<li>写好广播接收器</li>
<li>注册好广播接收器的要接收的广播地址，然后使用localBroadcastManager.registerReceiver(mBroadcastReceiver,intentFilter);方法进行注册</li>
<li>记得在onDestroy()中取消注册</li>
</ol>
<h2 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h2><p>BroadcastReceiver 是针对应用间、应用与系统间、应用内部进行通信的一种方式<br>LocalBroadcastReceiver 仅在自己的应用内发送接收广播，也就是只有自己的应用能收到，数据更加安全广播只在这个程序里，而且效率更高。<br><strong>BroadcastReceiver 使用</strong></p>
<ol>
<li><p>制作intent（可以携带参数）</p>
</li>
<li><p>使用sendBroadcast()传入intent;</p>
</li>
<li><p>制作广播接收器类继承BroadcastReceiver重写onReceive方法（或者可以匿名内部类啥的）</p>
</li>
<li><p>在java中（动态注册）或者直接在Manifest中注册广播接收器（静态注册）使用registerReceiver()传入接收器和intentFilter</p>
</li>
<li><p>取消注册可以在OnDestroy()函数中，unregisterReceiver()传入接收器<br>LocalBroadcastReceiver 使用</p>
</li>
<li><p>LocalBroadcastReceiver不能静态注册，只能采用动态注册的方式。<br>在发送和注册的时候采用，LocalBroadcastManager的sendBroadcast方法和registerReceiver方法</p>
</li>
<li><p>可以明确的知道正在发送的广播不会离开我们的程序，因此不用担心机密数据泄露问题</p>
</li>
<li><p>其他程序无法将广播发送到我们程序的内部，因此不需要担心会有安全漏洞的隐患</p>
</li>
<li><p>发送本地广播要比全局广播更加高效</p>
</li>
</ol>
<ul>
<li>BroadcastReceiver 是跨应用广播，利用Binder机制实现，支持动态和静态两种方式注册方式。</li>
<li>LocalBroadcastReceiver 是应用内广播，利用Handler实现，利用了IntentFilter的match功能，提供消息的发布与接收功能，实现应用内通信，效率和安全性比较高，仅支持动态注册。</li>
</ul>
<p><strong>广播细分为三种:</strong></p>
<ul>
<li>普通广播</li>
<li>有序广播</li>
<li>本地广播</li>
</ul>
<p><strong>普通广播是什么？</strong><br>调用sendBroadcast()发送</p>
<p><strong>有序广播是什么？</strong><br>调用sendOrderedBroadcast()发送<br>广播接收者会按照priority优先级从大到小进行排序<br>优先级相同的广播，动态注册的广播优先处理<br>广播接收者还能对广播进行截断和修改</p>
<p><strong>本地广播的优点?</strong><br>效率更高。<br>发送的广播不会离开我们的应用，不会泄露关键数据。<br>其他程序无法将广播发送到我们程序内部，不会有安全漏洞。</p>
<p>现在BroadcastReceiver也不推荐使用静态注册了，8.0之后限制了绝大部分广播只能使用动态注册</p>
<blockquote>
<p>应用内广播现在还有人用吗？已经被EventBus类似的事件替换了吧？<br>emmmm……</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>EventBus 源码分析与踩坑指南</title>
    <url>/Android/EventBus-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>EventBus是一个使用发布者&#x2F;订阅者模式 并且低耦合的Android开源库。 EventBus只需几行代码即可实现中央通信解耦类：简化代码，删除依赖关系，加快应用程序开发速度。</p>
<span id="more"></span>

<h2 id="EventBus-源码分析"><a href="#EventBus-源码分析" class="headerlink" title="EventBus 源码分析"></a>EventBus 源码分析</h2><h3 id="EventBus-构造器"><a href="#EventBus-构造器" class="headerlink" title="EventBus 构造器"></a>EventBus 构造器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static EventBus getDefault() &#123;</span><br><span class="line">    if (defaultInstance == null) &#123;</span><br><span class="line">        synchronized (EventBus.class) &#123;</span><br><span class="line">            if (defaultInstance == null) &#123;</span><br><span class="line">                defaultInstance = new EventBus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return defaultInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的是传统双重检查构造的方法，使得在任意线程中调用构造器都是线程安全的。</p>
<p>默认构造器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public EventBus() &#123;</span><br><span class="line">    this(DEFAULT_BUILDER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中传入的默认构造器为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">    logger = builder.getLogger();</span><br><span class="line">    //以被订阅事件类为名为 key 记录注册了哪些 onEvent() 方法</span><br><span class="line">    subscriptionsByEventType = new HashMap&lt;&gt;();</span><br><span class="line">    //以注册的类为键值，记录该类所注册的所有事件类型，值为一个Event的class对象的列表</span><br><span class="line">    typesBySubscriber = new HashMap&lt;&gt;();</span><br><span class="line">    //记录了所有粘性事件</span><br><span class="line">    stickyEvents = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    //三个Poster, 负责在不同的线程中调用订阅者的方法</span><br><span class="line">    mainThreadSupport = builder.getMainThreadSupport();</span><br><span class="line">    mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;</span><br><span class="line">    backgroundPoster = new BackgroundPoster(this);</span><br><span class="line">    asyncPoster = new AsyncPoster(this);</span><br><span class="line">    indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;</span><br><span class="line">    //方法的查找类，用于查找某个订阅者类中有哪些注册的方法</span><br><span class="line">    subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">            builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">    //一些开关       </span><br><span class="line">    logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">    logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">    sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">    sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">    throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">    eventInheritance = builder.eventInheritance;</span><br><span class="line">    //线程池</span><br><span class="line">    executorService = builder.executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个类中会有的多个方法去监听事件，<code>Subscription</code>封装了一个注册信息，如下</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final class Subscription &#123;</span><br><span class="line">    //订阅的类</span><br><span class="line">    final Object subscriber;</span><br><span class="line">    //订阅方法封装</span><br><span class="line">    final SubscriberMethod subscriberMethod;</span><br><span class="line">    /**</span><br><span class="line">     * Becomes false as soon as &#123;@link EventBus#unregister(Object)&#125; is called, which is checked by queued event delivery</span><br><span class="line">     * &#123;@link EventBus#invokeSubscriber(PendingPost)&#125; to prevent race conditions.</span><br><span class="line">     */</span><br><span class="line">    volatile boolean active;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SubscriberMethod &#123;</span><br><span class="line">    //方法</span><br><span class="line">    final Method method;</span><br><span class="line">    //订阅线程</span><br><span class="line">    final ThreadMode threadMode;</span><br><span class="line">    //订阅的事件类的 class</span><br><span class="line">    final Class&lt;?&gt; eventType;</span><br><span class="line">    //事件优先级</span><br><span class="line">    final int priority;</span><br><span class="line">    //是否是粘性事件</span><br><span class="line">    final boolean sticky;</span><br><span class="line">    /** Used for efficient comparison */</span><br><span class="line">    //比较用到的字符串</span><br><span class="line">    String methodString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类和方法名唯一确定一条注册信息，Subscription.active 唯一确定该注册信息是否有效。<br><code>subscriptionsByEventType</code> 以事件的类名为 key ，value 为一个处理事件类型为该键值的 Subscription 的列表。<br><code>typesBySubscriber</code>根据一个订阅者记录了注册了哪些事件。<br>这二者从不同维度上记录的订阅事件和被订阅者之间的关系，在使用的注册，调度中更为高效。</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>注册的 <code>register()</code> 方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void register(Object subscriber) &#123;</span><br><span class="line">    //订阅者的类名</span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    //找到所有订阅者订阅的事件，并包装返回</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    //遍历这些事件</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历之后的订阅方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">    Subscription newSubscription = new Subscription(subscriber, subscriberMethod);</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    if (subscriptions == null) &#123;</span><br><span class="line">        subscriptions = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">            throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;</span><br><span class="line">                    + eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int size = subscriptions.size();</span><br><span class="line">    for (int i = 0; i &lt;= size; i++) &#123;</span><br><span class="line">        if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">            subscriptions.add(i, newSubscription);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">    if (subscribedEvents == null) &#123;</span><br><span class="line">        subscribedEvents = new ArrayList&lt;&gt;();</span><br><span class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">    &#125;</span><br><span class="line">    subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line">    if (subscriberMethod.sticky) &#123;</span><br><span class="line">        if (eventInheritance) &#123;</span><br><span class="line">            // Existing sticky events of all subclasses of eventType have to be considered.</span><br><span class="line">            // Note: Iterating over all events may be inefficient with lots of sticky events,</span><br><span class="line">            // thus data structure should be changed to allow a more efficient lookup</span><br><span class="line">            // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span><br><span class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">            for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                if (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                    Object stickyEvent = entry.getValue();</span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很长，逻辑很简单，先构建了<code>Subscription</code>了对象，分别放入两个数据结构里。<br>对于<code>subscriptionsByEventType</code>先查再加，如有重复说明一个类中有多个相同的订阅事件，注意事件的优先级，放入列表。如果添加过则抛出异常。<br>对于<code>typesBySubscriber</code>先查再加。<br>最后检查订阅者注册时是否已存在粘性事件，处理即可。</p>
<h3 id="反注册"><a href="#反注册" class="headerlink" title="反注册"></a>反注册</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public synchronized void unregister(Object subscriber) &#123;</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">    if (subscribedTypes != null) &#123;</span><br><span class="line">        for (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">            unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        typesBySubscriber.remove(subscriber);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        logger.log(Level.WARNING, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到其中最主要的是<code>unsubscribeByEventType</code>这个方法，继续查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123;</span><br><span class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    if (subscriptions != null) &#123;</span><br><span class="line">        int size = subscriptions.size();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            Subscription subscription = subscriptions.get(i);</span><br><span class="line">            if (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                subscription.active = false;</span><br><span class="line">                subscriptions.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即从 <code>subscriptionsByEventType</code>找到所有的订阅事件包装类，分别更新这些包装类。</p>
<h4 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void post(Object event) &#123;</span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">    if (!postingState.isPosting) &#123;</span><br><span class="line">        postingState.isMainThread = isMainThread();</span><br><span class="line">        postingState.isPosting = true;</span><br><span class="line">        if (postingState.canceled) &#123;</span><br><span class="line">            throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                postSingleEvent(eventQueue.remove(0), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            postingState.isPosting = false;</span><br><span class="line">            postingState.isMainThread = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如注释所说，<code>post()</code>是将事件发送到 EventBus ,具体什么时候调用时由 EventBus 调度，我们继续查看原理。<br>因为发布事件的线程即调用<code>post()</code>的线程与调用订阅者方法的线程不同，所以设计了一个<code>PostingThreadState</code>来保存发送的状态。<br><code>PostingThreadState</code>的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final static class PostingThreadState &#123;</span><br><span class="line">    //用来保存当前线程需要发送的事件</span><br><span class="line">    final List&lt;Object&gt; eventQueue = new ArrayList&lt;&gt;();</span><br><span class="line">    boolean isPosting;</span><br><span class="line">    boolean isMainThread;</span><br><span class="line">    Subscription subscription;</span><br><span class="line">    Object event;</span><br><span class="line">    boolean canceled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>故发送事件中最重要的步骤是<code>postSingleEvent()</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123;</span><br><span class="line">    Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">    boolean subscriptionFound = false;</span><br><span class="line">    if (eventInheritance) &#123;</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">        int countTypes = eventTypes.size();</span><br><span class="line">        for (int h = 0; h &lt; countTypes; h++) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!subscriptionFound) &#123;</span><br><span class="line">        if (logNoSubscriberMessages) &#123;</span><br><span class="line">            logger.log(Level.FINE, &quot;No subscribers registered for event &quot; + eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">            post(new NoSubscriberEvent(this, event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>eventInheritance</code>这个开关是表明是否考虑时间类型的继承关系，默认为true，然后调用<code>lookupAllEventTypes()</code>去查找所有订阅了这个时间的Class，最后调用<code>postSingleEventForEventType()</code>来判断是否查找到对应的订阅方法，最后将事件通过<code>postSingleEventForEventType()</code>方法继续处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123;</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">        for (Subscription subscription : subscriptions) &#123;</span><br><span class="line">            postingState.event = event;</span><br><span class="line">            postingState.subscription = subscription;</span><br><span class="line">            boolean aborted = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                aborted = postingState.canceled;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                postingState.event = null;</span><br><span class="line">                postingState.subscription = null;</span><br><span class="line">                postingState.canceled = false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (aborted) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过一次 CopyOnWriteArrayList ，每次对List 的修改都会立即同步一份。在这里找到每一个包装类，通过方法<code>postToSubscription()</code>来进行分发，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;</span><br><span class="line">    switch (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        case POSTING:</span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            break;</span><br><span class="line">        case MAIN:</span><br><span class="line">            if (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case MAIN_ORDERED:</span><br><span class="line">            if (mainThreadPoster != null) &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // temporary: technically not correct as poster not decoupled from subscriber</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case BACKGROUND:</span><br><span class="line">            if (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case ASYNC:</span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里到了最后的分发事件，在构造方法中构造的四个线程池，加入响应的队列，异步执行，</p>
<p>执行方法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void invokeSubscriber(Subscription subscription, Object event) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">        handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">    &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Unexpected exception&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了反射，反射调用订阅者的方法，方法存储在subsription的subsribeMethod变量中。</p>
<h2 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h2><ul>
<li>优点：洒脱的解藕，在多个界面传递时省去了层层的值传递。</li>
<li>缺点：EventBus 直译为事件总线，但是其实总线就是 Bus 也就是公交车。而 RxJava 更像一个滴滴。他直接链接你的两个或多个需要通信的类。传输数据，当然你可以做一个很大的专车，穿梭在所有类之间。<ul>
<li>对于 RxJava， Subscriber 明确的知道他 Subscribe 的是谁明确知道要做出什么反应；而对于 EventBus 在项目复杂之后，每个 Observaber 不知道会有什事件下发下来。</li>
<li>不方便调试，对于后续维护来说，如果你没有文档，靠自己找事件被传递到哪里去了还是挺不方便的。</li>
</ul>
</li>
</ul>
<h2 id="踩坑纪要"><a href="#踩坑纪要" class="headerlink" title="踩坑纪要"></a>踩坑纪要</h2><h3 id="register-和-unregister-方法"><a href="#register-和-unregister-方法" class="headerlink" title="register() 和 unregister() 方法"></a><code>register()</code> 和 <code>unregister()</code> 方法</h3><ul>
<li><p>调用时机：</p>
<p>  <code>register()</code> 和 <code>unregister()</code> 方法的不正确调用是 EventBus 使用中遇到的问题的多数原因，包括且不限于<strong>重复注册</strong>、<strong>注册未收回</strong>、<strong>提前收回</strong>等情况。<br>  多数情况下，<code>register()</code> 方法是伴随着 Activity&#x2F;Fragment 的生命周期从 onCreate 开始到 onDestroy 结束。如果将 <code>register()</code> 和 <code>unregister()</code>放在 onStart&#x2F;onStop 中执行，那就不要怪页面切到后台&#x2F;不可见时订阅的事件不执行了。有时需要控制不可见的页面不接受事件，则需要放在 onStart&#x2F;onStop 中执行。<br>  如果不需要后台的页面立即执行事件，也可以使用粘性广播，当页面重新切回前台时，在 onStart 重新执行额时候会注册订阅者，会立马收到之前发送的粘性广播并执行。<br>  放在 onCreate 方法中就一定可行么？也不尽然，因为 onCreate 也有可能执行多次，如果一个页面已经存在，多次 startActivity 会创建多个 Activity 实例，就会执行多次，所以调用的时候要注意。</p>
</li>
<li><p>收取粘性广播更新 UI 的时候注意页面控件是否初始化完成，先初始化控件，再注册粘性广播执行。</p>
</li>
</ul>
<h3 id="对象生成多次"><a href="#对象生成多次" class="headerlink" title="对象生成多次"></a>对象生成多次</h3><p>订阅者是对象的实例，当程序中通过种种情况使用的实例不是当时注册 EventBus 的那个实例了（包括且不限于<strong>序列化于反序列化造成另外对象</strong>、<strong>Activity&#x2F;Fragment 销毁后重建导致前后不一致</strong>、**多级传递把自己传晕了导致对象变了(本人亲历)**等等，遇事不决打一下 Log 看看是否是同一个对象吧。</p>
<h3 id="订阅事件的执行线程"><a href="#订阅事件的执行线程" class="headerlink" title="订阅事件的执行线程"></a>订阅事件的执行线程</h3><p>订阅事件的时候会判断订阅者的 ThreadMode ，从而决定在什么线程下执行事件响应函数。</p>
<ul>
<li>PostThread：默认的 ThreadMode，表示在执行 Post 操作的线程直接调用订阅者的事件响应方法，不论该线程是否为主线程（UI 线程）。当该线程为主线程时，响应方法中不能有耗时操作，否则有卡主线程的风险。适用场景：对于是否在主线程执行无要求，但若 Post 线程为主线程，不能耗时的操作；</li>
<li>MainThread：在主线程中执行响应方法。如果发布线程就是主线程，则直接调用订阅者的事件响应方法，否则通过主线程的 Handler 发送消息在主线程中处理——调用订阅者的事件响应函数。显然，MainThread类的方法也不能有耗时操作，以避免卡主线程。适用场景：必须在主线程执行的操作；</li>
<li>BackgroundThread：在后台线程中执行响应方法。如果发布线程不是主线程，则直接调用订阅者的事件响应函数，否则启动唯一的后台线程去处理。由于后台线程是唯一的，当事件超过一个的时候，它们会被放在队列中依次执行，因此该类响应方法虽然没有PostThread类和MainThread类方法对性能敏感，但最好不要有重度耗时的操作或太频繁的轻度耗时操作，以造成其他操作等待。适用场景：操作轻微耗时且不会过于频繁，即一般的耗时操作都可以放在这里；</li>
<li>Async：不论发布线程是否为主线程，都使用一个空闲线程来处理。和BackgroundThread不同的是，Async类的所有线程是相互独立的，因此不会出现卡线程的问题。适用场景：长耗时操作，例如网络访问。</li>
</ul>
<h3 id="注意-EventBus-事件的混淆"><a href="#注意-EventBus-事件的混淆" class="headerlink" title="注意 EventBus 事件的混淆"></a>注意 EventBus 事件的混淆</h3><p>EventBus是采用反射机制调用的绑定的方法，如果混淆则无法找到了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/MicroBlog/Hello%20World/</url>
    <content><![CDATA[<p><code>sudo apt-get install GirlFriend</code><br>正在读取软件包列表… <br>完成正在分析软件包的依赖关系树… <br>完成有一些软件包无法被安装。<br>下列的信息可能会对解决问题有所帮助：<br>下列的软件包有不能满足的依赖关系：<br><code>GirlFriend</code>: 依赖: <code>House</code> 但是它将不会被安装<br><code>GirlFriend</code>: 依赖: <code>Car</code> 但是它将不会被安装<br><code>House</code> ,<code>Car</code> : 依赖: <code>Money</code> 但是它将不会被安装<br><code>Error</code>: 无法安装的软件包</p>
]]></content>
      <categories>
        <category>MicroBlog</category>
      </categories>
      <tags>
        <tag>戏说</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 建站笔记</title>
    <url>/Hexo/Hexo-%E5%BB%BA%E7%AB%99%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="建站流程"><a href="#建站流程" class="headerlink" title="建站流程"></a>建站流程</h3><span id="more"></span>

<p><code>//todo</code></p>
<h3 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h3><ul>
<li>Permalink</li>
<li>GitHub</li>
<li>多说</li>
<li>GitHub 挂饰</li>
</ul>
<p><code>//todo</code></p>
<h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><h4 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h4><ul>
<li>多说</li>
<li>不蒜子</li>
<li>Avatar</li>
<li>Menu</li>
<li>Social</li>
<li>Sidebar</li>
</ul>
<p><code>//todo</code></p>
<h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><ul>
<li>Atom</li>
<li>七牛</li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>容器-HashMap 实现原理</title>
    <url>/uncategorized/Java%20%E5%AE%B9%E5%99%A8%20HashMap%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java 容器篇：容器总结</title>
    <url>/Java/Java%20%E5%AE%B9%E5%99%A8%E7%AF%87%EF%BC%9A%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Java 中使用的容器从大的方面上来粉可以分为两种：<strong>Collection</strong>和<strong>Map</strong>,区别也很简单，Collection存储的是单个值，Map存储的是键值对。</p>
<ul>
<li><p>Collection 的划分分为 List，Set，Queue</p>
<ul>
<li>List:常见接口有ArrayList，LinkedList，AbstractList， CopyOnWriteArrayList， Vector，Stack；</li>
<li>Set：常见接口有HashSet，TreeSet，LinkedHashSet，AbstractSet，CopyOnWriteArraySet，EnumSet；</li>
<li>Queue：常见接口有（阻塞队列）ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue（双端队列）ArrayDeque、LinkedBlockingDeque、LinkedList</li>
</ul>
</li>
<li><p>Map 的常见接口有<strong>Hashmap</strong>、Treemap、Hashtable、AbstractMap、ConcurrentHashMap、 LinkedHashMap、WeakHashMap</p>
</li>
</ul>
<span id="more"></span>

<h1 id="一、Collection接口"><a href="#一、Collection接口" class="headerlink" title="一、Collection接口"></a><strong>一、Collection接口</strong></h1><p>　　Collection接口是最基本的集合接口，它不提供直接的实现，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。Collection所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。他包含了最基础的一些接口，如 <code>isEmpty()</code>,<code>add(Object o)</code>,<code>remove(Object o)</code>.<code>clear()</code>等<br>　　<strong>在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数</strong>，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。</p>
<h1 id="二、List接口"><a href="#二、List接口" class="headerlink" title="二、List接口"></a><strong>二、List接口</strong></h1><p>　　 List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p>
<h3 id="2-1、ArrayList"><a href="#2-1、ArrayList" class="headerlink" title="2.1、ArrayList"></a><strong>2.1、ArrayList</strong></h3><p>　　ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。<br>　　size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。<br><strong>ArrayList擅长于随机访问</strong>。同时ArrayList是非同步的。</p>
<h3 id="2-2、LinkedList"><a href="#2-2、LinkedList" class="headerlink" title="2.2、LinkedList"></a><strong>2.2、LinkedList</strong></h3><p>　　同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。<br>　　由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。</p>
<p>　　与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：</p>
<blockquote>
<p>List list &#x3D; Collections.synchronizedList(new LinkedList(…));</p>
</blockquote>
<h3 id="2-3、Vector（已过时）"><a href="#2-3、Vector（已过时）" class="headerlink" title="2.3、Vector（已过时）"></a><strong>2.3、Vector（已过时）</strong></h3><p>　　与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。</p>
<h3 id="2-4、Stack（已过时）"><a href="#2-4、Stack（已过时）" class="headerlink" title="2.4、Stack（已过时）"></a><strong>2.4、Stack（已过时）</strong></h3><p>　　Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。<br>　　详细：<a href="http://www.cnblogs.com/chenpi/p/5258450.html">Vector和Stack(已过时，不建议使用)</a></p>
<h3 id="Vector和ArrayList的比较"><a href="#Vector和ArrayList的比较" class="headerlink" title="Vector和ArrayList的比较"></a><strong>Vector和ArrayList的比较</strong></h3><p>　　1，vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。<br>　　2，如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。<br>　　3，如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。而如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。<br>　　ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！</p>
<h3 id="Aarraylist和Linkedlist的比较"><a href="#Aarraylist和Linkedlist的比较" class="headerlink" title="Aarraylist和Linkedlist的比较"></a><strong>Aarraylist和Linkedlist的比较</strong></h3><p>　　1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<br>　　2.对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。<br>　　3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。<br>　　这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a><strong>分类</strong></h3><table>
<thead>
<tr>
<th>类</th>
<th align="center">是否线程安全</th>
<th align="right">是否有序</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td align="center">否</td>
<td align="right">是</td>
</tr>
<tr>
<td>LinkedList</td>
<td align="center">否</td>
<td align="right">是</td>
</tr>
<tr>
<td>Vector</td>
<td align="center">是</td>
<td align="right">是</td>
</tr>
<tr>
<td>Stack</td>
<td align="center">是</td>
<td align="right">是</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>可以通过Collections.synchronizedList包装成线程安全的List</strong></p>
</blockquote>
<h1 id="三、Set接口"><a href="#三、Set接口" class="headerlink" title="三、Set接口"></a><strong>三、Set接口</strong></h1><p>　　Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样运行null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)&#x3D;&#x3D;true，则必定会产生某些问题。实现了Set接口的集合有：EnumSet、HashSet、TreeSet。</p>
<h3 id="3-1、AbstractSet"><a href="#3-1、AbstractSet" class="headerlink" title="3.1、AbstractSet"></a><strong>3.1、AbstractSet</strong></h3><p>　　EnumSet、HashSet、TreeSet的父类</p>
<h3 id="3-2、EnumSet"><a href="#3-2、EnumSet" class="headerlink" title="3.2、EnumSet"></a><strong>3.2、EnumSet</strong></h3><p>　　是枚举的专用Set。所有的元素都是枚举类型。</p>
<h3 id="3-3、HashSet"><a href="#3-3、HashSet" class="headerlink" title="3.3、HashSet"></a><strong>3.3、HashSet</strong></h3><p>　　HashSet堪称查询速度最快的集合，因为其内部是以HashMap来实现的。<strong>它内部元素的顺序是由哈希码来决定的</strong>，所以它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。</p>
<h3 id="3-4、LinkedHashSet"><a href="#3-4、LinkedHashSet" class="headerlink" title="3.4、LinkedHashSet"></a><strong>3.4、LinkedHashSet</strong></h3><p>　　LinkedHashSet是HashSet的子类，此实现与 HashSet 的不同之外在于，后者维护着一个运行于所有条目的<strong>双链表</strong>。此链接列表定义了迭代顺序，即按照将元素插入到 set 中的顺序（插入顺序）进行迭代。注意，插入顺序不 受在 set 中重新插入的 元素的影响。<br>　　<strong>也就是说，LinkedHashSet是迭代有序的HashSet</strong></p>
<h3 id="3-5、TreeSet"><a href="#3-5、TreeSet" class="headerlink" title="3.5、TreeSet"></a><strong>3.5、TreeSet</strong></h3><p>　　基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现。它是使用元素的<strong>自然顺序</strong>（例如1,2,3）对元素进行排序，或者根据创建Set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。<strong>（实现了SortSet）</strong></p>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a><strong>分类</strong></h3><table>
<thead>
<tr>
<th>类</th>
<th align="center">是否线程安全</th>
<th align="right">是否有序</th>
</tr>
</thead>
<tbody><tr>
<td>AbstractSet</td>
<td align="center">否</td>
<td align="right">否</td>
</tr>
<tr>
<td>EnumSet</td>
<td align="center">否</td>
<td align="right">否</td>
</tr>
<tr>
<td>HashSet</td>
<td align="center">否</td>
<td align="right">否</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td align="center">否</td>
<td align="right">是</td>
</tr>
<tr>
<td>TreeSet</td>
<td align="center">否</td>
<td align="right">是</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>可以通过Collections.synchronizedSet来包装线程安全的Set</strong></p>
</blockquote>
<h1 id="四、Map接口"><a href="#四、Map接口" class="headerlink" title="四、Map接口"></a><strong>四、Map接口</strong></h1><p>　　Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。</p>
<h3 id="4-1、AbstractMap"><a href="#4-1、AbstractMap" class="headerlink" title="4.1、AbstractMap"></a><strong>4.1、AbstractMap</strong></h3><p>　　HashMap， TreeMap，WeakHashMap ，ConcurrentHash的父类</p>
<h3 id="4-2、HashMap"><a href="#4-2、HashMap" class="headerlink" title="4.2、HashMap"></a><strong>4.2、HashMap</strong></h3><p>　　以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。<br>　　<strong>HashMap可以用null作为key和value</strong></p>
<h3 id="4-3、LinkedHashMap"><a href="#4-3、LinkedHashMap" class="headerlink" title="4.3、LinkedHashMap"></a><strong>4.3、LinkedHashMap</strong></h3><p>　　此实现与 HashMap 的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序通常就是将键插入到映射中的顺序（插入顺序）。注意，如果在映射中重新插入 键，则插入顺序不受影响<br>　　<strong>也就是说，LinkedHashMap是迭代有序的HashMap</strong></p>
<h3 id="4-4、HashTable"><a href="#4-4、HashTable" class="headerlink" title="4.4、HashTable"></a><strong>4.4、HashTable</strong></h3><p>　　也是以哈希表数据结构实现的，解决冲突时与HashMap也一样也是采用了散列链表的形式，不过性能比HashMap要低<br>　　<strong>HashTable不支持用null作为key或者value</strong></p>
<h3 id="4-5、TreeMap"><a href="#4-5、TreeMap" class="headerlink" title="4.5、TreeMap"></a><strong>4.5、TreeMap</strong></h3><p>　　键以某种排序规则排序，内部以red-black（红-黑）树数据结构实现，实现了SortedMap接口，所以是有序的</p>
<h3 id="4-6、WeakHashMap"><a href="#4-6、WeakHashMap" class="headerlink" title="4.6、WeakHashMap"></a><strong>4.6、WeakHashMap</strong></h3><p>　　以弱键 实现的基于哈希表的 Map。在 WeakHashMap 中，当某个键不再正常使用时，将自动移除其条目。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。丢弃某个键时，其条目从映射中有效地移除，因此，该类的行为与其他的 Map 实现有所不同<br>　　<strong>该map的键类似于弱引用</strong></p>
<h3 id="HashMap与TreeMap的比较"><a href="#HashMap与TreeMap的比较" class="headerlink" title="HashMap与TreeMap的比较"></a><strong>HashMap与TreeMap的比较</strong></h3><p>　　1、HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。HashMap中元素的排列顺序是不固定的）。<br>　　2、在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。 这个TreeMap没有调优选项，因为该树总处于平衡状态。</p>
<h3 id="Hashtable与Hashmap的比较"><a href="#Hashtable与Hashmap的比较" class="headerlink" title="Hashtable与Hashmap的比较"></a><strong>Hashtable与Hashmap的比较</strong></h3><p>　　1、历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。<br>　　2、同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程不安全的，不是同步的 。<br>　　3、值：只有HashMap可以让你将空值作为一个表的条目的key或value 。</p>
<h3 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a><strong>分类</strong></h3><table>
<thead>
<tr>
<th>类</th>
<th align="center">是否线程安全</th>
<th>是否有序</th>
</tr>
</thead>
<tbody><tr>
<td>AbstractMap</td>
<td align="center">否</td>
<td>否</td>
</tr>
<tr>
<td>HashMap</td>
<td align="center">否</td>
<td>否</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td align="center">否</td>
<td>是</td>
</tr>
<tr>
<td>HashTable</td>
<td align="center">是</td>
<td>否</td>
</tr>
<tr>
<td>TreeMap</td>
<td align="center">否</td>
<td>是</td>
</tr>
<tr>
<td>WeakHashMap</td>
<td align="center">否</td>
<td>否</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>可以通过 Collections.synchronizedMap包装成线程安全的map</strong></p>
</blockquote>
<h1 id="五、Queue"><a href="#五、Queue" class="headerlink" title="五、Queue"></a><strong>五、Queue</strong></h1><p>　　队列，它主要分为两大类，一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。</p>
<h1 id="六、集合工具"><a href="#六、集合工具" class="headerlink" title="六、集合工具"></a><strong>六、集合工具</strong></h1><p>集合工具包括Arrays 和 Collection，其中Arrays用于操作数组，Collection用于操作Collection的子类集合</p>
<h1 id="七、对集合的选择"><a href="#七、对集合的选择" class="headerlink" title="七、对集合的选择"></a><strong>七、对集合的选择</strong></h1><h3 id="7-1、对List的选择"><a href="#7-1、对List的选择" class="headerlink" title="7.1、对List的选择"></a><strong>7.1、对List的选择</strong></h3><p>　　1、对于随机查询与迭代遍历操作，数组比所有的容器都要快。所以在随机访问中一般使用ArrayList<br>　　2、LinkedList使用双向链表对元素的增加和删除提供了非常好的支持，而ArrayList执行增加和删除元素需要进行元素位移。<br>　　3、对于Vector而已，我们一般都是避免使用。<br>　　4、将ArrayList当做首选，毕竟对于集合元素而已我们都是进行遍历，只有当程序的性能因为List的频繁插入和删除而降低时，再考虑LinkedList。</p>
<h3 id="7-2、对Set的选择"><a href="#7-2、对Set的选择" class="headerlink" title="7.2、对Set的选择"></a><strong>7.2、对Set的选择</strong></h3><p>　　1、HashSet由于使用HashCode实现，所以在某种程度上来说它的性能永远比TreeSet要好，尤其是进行增加和查找操作。<br>　　２、虽然TreeSet没有HashSet性能好，但是由于它可以维持元素的排序，所以它还是存在用武之地的。</p>
<h3 id="7-3、对Map的选择"><a href="#7-3、对Map的选择" class="headerlink" title="7.3、对Map的选择"></a><strong>7.3、对Map的选择</strong></h3><p>　　1、HashMap与HashSet同样，支持快速查询。虽然HashTable速度的速度也不慢，但是在HashMap面前还是稍微慢了些，所以HashMap在查询方面可以取代HashTable。<br>　　2、由于TreeMap需要维持内部元素的顺序，所以它通常要比HashMap和HashTable慢。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 的内存模型与 volatile 关键字</title>
    <url>/Java/Java-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E-volatile-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="Java-的内存模型"><a href="#Java-的内存模型" class="headerlink" title="Java 的内存模型"></a>Java 的内存模型</h2><p>Java 的内存模型（Java Memory Model，JMM）定义了程序中变量的访问规则，即程序的执行次序。</p>
<span id="more"></span>

<p>Java内存模型规定所有的变量都是存在主存当中，每个线程都有自己的工作内存。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。<br>Java 内存模型为程序的原子性、可见性以及有序性的保证：</p>
<ul>
<li><p>原子性<br>  对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。<br>  只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p>  <em>x++和 x &#x3D; x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</em></p>
<p>  大范围的原子性操作通过 synchronized 和 Lock 来实现</p>
</li>
<li><p>可见性：<br>  Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。<br>  而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。<br>  synchronized和Lock也能够保证可见性，</p>
</li>
<li><p>有序性<br>  在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<br>  在Java里面，可以通过volatile关键字来保证一定的“有序性”<br>  Java 还具有一些先天的有序性，也称为 happens-before 原则，如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
</ul>
</li>
</ul>
<h2 id="volatole-关键字"><a href="#volatole-关键字" class="headerlink" title="volatole 关键字"></a>volatole 关键字</h2><p>被 volatole 修饰的共享变量会具有两层含义：<br>　　1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。即<strong>它会保证修改的值会立即被更新到主存</strong><br>　　2. 禁止进行指令重排序。保证被 volatile 修饰变量与其他指令的绝对顺序。</p>
<h4 id="volatole-的实现原理"><a href="#volatole-的实现原理" class="headerlink" title="volatole 的实现原理"></a>volatole 的实现原理</h4><p>volatole 是通过内存屏障来实现加锁操作的</p>
<blockquote>
<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
</blockquote>
<p>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<ul>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中单例的实现与线程安全</title>
    <url>/Java/Java-%E4%B8%AD%E5%8D%95%E4%BE%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="Java-中单例的实现与线程安全"><a href="#Java-中单例的实现与线程安全" class="headerlink" title="Java 中单例的实现与线程安全"></a>Java 中单例的实现与线程安全</h1><p>单例模式事一种常用的设计模式，其目的是为了该类只拥有一个实例，避免具有相同功能的多个对象消耗过多的资源，创建一个单例需要注意以下问题：</p>
<ol>
<li>单例功能：基本功能</li>
<li>延迟加载：避免不必要的资源消耗</li>
<li>线程安全：多个线程同时创建对象时为同一个对象</li>
<li>没有性能问题：创建函数不能影响效率</li>
<li>防止序列化产生新对象：安全</li>
<li>防止反射攻击：安全</li>
</ol>
<span id="more"></span>

<h2 id="饿汉式（类加载时就完成初始化）"><a href="#饿汉式（类加载时就完成初始化）" class="headerlink" title="饿汉式（类加载时就完成初始化）"></a>饿汉式（类加载时就完成初始化）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton instance;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：简单粗暴，加载类的时候就初始化完成了，线程安全。<br>缺点：消耗资源，如果使用时机较晚或不使用，浪费内存。</p>
<h2 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式(线程不安全)"></a>懒汉式(线程不安全)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton instance;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：延迟初始化，避免了不必要的内存开销；<br>缺点：线程不安全。</p>
<h2 id="懒汉式（线程安全，同步方法）"><a href="#懒汉式（线程安全，同步方法）" class="headerlink" title="懒汉式（线程安全，同步方法）"></a>懒汉式（线程安全，同步方法）</h2><p>使用<code>synchronized</code>修饰获取方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton instance;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：延迟初始化，避免了不必要的内存开销；线程安全；<br>缺点：每次获取实例都需要同步，其实只需要第一次同步就可以了。</p>
<h2 id="懒汉式（线程安全，同步代码块-DCL-double-check-lock）"><a href="#懒汉式（线程安全，同步代码块-DCL-double-check-lock）" class="headerlink" title="懒汉式（线程安全，同步代码块 DCL:double check lock）"></a>懒汉式（线程安全，同步代码块 DCL:double check lock）</h2><p>使用<code>synchronized</code>同步 new 方法，内外加双重判断，volatile 修饰实例。<br>synchronized 能保证每次只有一个线程访问代码块，volatile 保证了 instance 创建的原子性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile Singleton instance;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果实现了Serializable, 必须重写这个方法</span><br><span class="line">     */</span><br><span class="line">    private Object readResolve() throws ObjectStreamException &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    /**</span><br><span class="line">     * 私有化构造方法</span><br><span class="line">     */</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例没有绑定关系，</span><br><span class="line">     * 而且只有被调用到才会装载，从而实现了延迟加载</span><br><span class="line">     */</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 静态初始化器，由JVM来保证线程安全</span><br><span class="line">         */</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：简单粗暴，线程安全，高效，自动避免序列化&#x2F;反序列化攻击、反射攻击(枚举类不能通过反射生成)<br>缺点：可读性差</p>
<p>关联阅读</p>
<blockquote>
<h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><p>synchronized 是 Java 中的关键字，是利用锁的机制来控制多线程同步的关键字.<br>锁的性质：</p>
<ol>
<li>互斥性&#x2F;原子性：同一时间只允许一个线程持有某个对象锁，通过对锁的持有来保证同一时间只有一个线程对需同步的代码块(复合操作)进行访问；</li>
<li>可见性：当一个线程释放锁之后，对共享变量所做的更改对之后获取该锁的另一个线程可见；<br>锁的分类:</li>
<li>对象锁: 在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰。</li>
<li>类锁:在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">修饰代码块</th>
<th align="center">修饰代码块</th>
</tr>
</thead>
<tbody><tr>
<td align="center">获取对象锁</td>
<td align="center">synchronized(this|object) {}</td>
<td align="center">修饰非静态方法</td>
</tr>
<tr>
<td align="center">获取类锁</td>
<td align="center">synchronized(类.class) {}</td>
<td align="center">修饰静态方法</td>
</tr>
</tbody></table>
<p><strong>对于同一种锁的访问是同步的</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode解题笔记</title>
    <url>/uncategorized/LeetCode%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="LeetCode-解题笔记"><a href="#LeetCode-解题笔记" class="headerlink" title="LeetCode 解题笔记"></a>LeetCode 解题笔记</h1><p><a href="https://github.com/ArtarisCN/LeetCode">Artaris 的 LeetCode</a></p>
<span id="more"></span>

<h3 id="827-Making-A-Large-Island"><a href="#827-Making-A-Large-Island" class="headerlink" title="827. Making A Large Island"></a>827. Making A Large Island</h3><p>这道题使用了并查集的知识，将所有岛先进行一次并查集操作，转化成只有两级的以代表元为根的树形结构，记录每个岛的父节点，在另一个数组中存储这个“合并岛”的大小。然后遍历为0的岛，判断是否有相邻为1的岛并去查找其父节点，找到父节点之后去查找该父节点的“合并岛”的大小（注意去重，有可能相邻的岛查到了形同的父节点），找到四个相邻岛加起来就是该为0的岛的结果，找到最大的结果即可。</p>
<h3 id="513-Find-Bottom-Left-Tree-Value"><a href="#513-Find-Bottom-Left-Tree-Value" class="headerlink" title="513. Find Bottom Left Tree Value"></a>513. Find Bottom Left Tree Value</h3><p>这道题要求找到二叉树最下面一排的第一个元素，思路就是每次遍历一层二叉树，并在遍历的时候记录第一个元素，全部遍历完，记录的那个元素就是结果。这里使用队列来进行二叉树的遍历，我使用 Java 中的 LinkedList 当作队列来使用，遇到的一个坑就是向队列队尾添加元素应该使用 offer 而不是使用 push ，<strong>push 在队列里是向队首添加元素的意思！</strong>,</p>
<ul>
<li>poll 队首弹出</li>
<li>offer 添加队尾</li>
<li>element 预览</li>
</ul>
<h3 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79. Word Search"></a>79. Word Search</h3><p>这道题是使用递归，同时传入所需子串和当前搜索位置，搜索完字符串则成功。需要注意的每一个位置只能使用一次，所以需要一个数组记录访问过的位置。</p>
<h3 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48. Rotate Image"></a>48. Rotate Image</h3><p>这道题是旋转一个数组，观察之后发现旋转是一环一环进行的，外圈怎么旋转也不会到内圈去（有点像玩魔方，角块怎么转也不会去边上），故使用递归一圈一圈旋转。</p>
<p>对于一圈一圈转的时候，是四条边互相交换位置，所以遍历一条边上的数，对于一条边上的某个值，作四次对换就OK了，就是确定四个值的位置时需要小心一些，算好就可以了。</p>
<h3 id="803-Bricks-Falling-When-Hit"><a href="#803-Bricks-Falling-When-Hit" class="headerlink" title="803. Bricks Falling When Hit"></a>803. Bricks Falling When Hit</h3><p>打砖块，如果没有和顶部相连的砖块就算作掉下来，此题通过逆向思维，先将所有的砖块打落，然后通过深度优先计算与顶部相连的砖块，是击落最后一块砖之后的结果，然后倒着加砖块，每加一块砖，重新计算一次与顶部相连的砖块，计算完成之后的数量减去上一只与顶部相连的砖块的值即是本次击落的砖块。</p>
<h3 id="147-Insertion-Sort-List"><a href="#147-Insertion-Sort-List" class="headerlink" title="147. Insertion Sort List"></a>147. Insertion Sort List</h3><p>通过两次遍历来插入链表，</p>
<ul>
<li>第一层遍历：遍历需要比较的节点，每次记录当前比较的节点、已排好序的链表的头节点、还未比较链表的头节点。</li>
<li>第二层遍历：将当前比较的节点一次与已排好序的链表进行比较，找到合适位置插入，注意如果是最大🔥最小的情况处理。<br>注意将每次当前比较的节点的后驱置为 null ，不然会造成链表循环。</li>
</ul>
<h3 id="164-Maximum-Gap"><a href="#164-Maximum-Gap" class="headerlink" title="164. Maximum Gap"></a>164. Maximum Gap</h3><p>要求找到排序之后的相差最大的两个值，这个题要求空间时间复杂度都是线性的，其实是考排序算法的。<br><del>偷鸡法：Arrays.sort(nums)</del><br>要求时间空间复杂度是线形的，这里使用基数排序来实现。</p>
<h3 id="523-Continuous-Subarray-Sum"><a href="#523-Continuous-Subarray-Sum" class="headerlink" title="523. Continuous Subarray Sum"></a>523. Continuous Subarray Sum</h3><p>这道题是要求找出是否有相邻的几个数的和正好是给定数据的倍数，思路是线形相加，每次对给定倍数取余数，并放到字典里，下次相加是如果字典里有这个余数，说明存在这样的数，用到了下面的原理：</p>
<blockquote>
<p>如果给定 …i…j…k… 的数据的序列，如果 sum(0,j) % divisor &#x3D; m 且 sum(0,k) % divisor &#x3D; m ,那么 [sum(j, k) - m] % divisor &#x3D; 0;</p>
</blockquote>
<p>想法很好，但是做起来有很多坑，如</p>
<ul>
<li>连续相邻的两个 0 是所有数的倍数</li>
<li>只有一个除数不算，要多于一个数才行</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>MarkDown 语法学习笔记</title>
    <url>/MarkDown/MarkDown-%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h5 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h5><span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
<h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><p>无序列表</p>
<ul>
<li>选项1</li>
<li>选项2</li>
<li>选项3</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 选项1</span><br><span class="line">- 选项2</span><br><span class="line">- 选项3</span><br></pre></td></tr></table></figure>
<p>有序列表</p>
<ol>
<li>选项1</li>
<li>选项2</li>
<li>选项3</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 选项1</span><br><span class="line">2. 选项2</span><br><span class="line">3. 选项3</span><br></pre></td></tr></table></figure>

<h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><p><a href="http://artaris.cn/">Aratis.CN</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Aratis.CN](http://artaris.cn)</span><br></pre></td></tr></table></figure>

<h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><p><img src="http://ww4.sinaimg.cn/bmiddle/aa397b7fjw1dzplsgpdw5j.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![示例图片](http://ww4.sinaimg.cn/bmiddle/aa397b7fjw1dzplsgpdw5j.jpg)</span><br></pre></td></tr></table></figure>
<h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><blockquote>
<p>一失足成千古风流人物。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 一失足成千古风流人物。</span><br></pre></td></tr></table></figure>
<h5 id="斜体和粗体"><a href="#斜体和粗体" class="headerlink" title="斜体和粗体"></a>斜体和粗体</h5><p><em>直到相思了无益</em>，<strong>未妨惆怅是轻狂</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*直到相思了无益*，**未妨惆怅是轻狂**。</span><br></pre></td></tr></table></figure>
<h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><table>
<thead>
<tr>
<th align="left">Tables</th>
<th align="center">Row  1 is</th>
<th align="right">Row  2 is</th>
</tr>
</thead>
<tbody><tr>
<td align="left">col 3 is</td>
<td align="center">A</td>
<td align="right">D</td>
</tr>
<tr>
<td align="left">col 2 is</td>
<td align="center">B</td>
<td align="right">E</td>
</tr>
<tr>
<td align="left">col 1 is</td>
<td align="center">C</td>
<td align="right">F</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| Tables        | Row  1 is     |  Row  2 is  |</span><br><span class="line">|:------------- |:-------------:| -----------:|</span><br><span class="line">| col 3 is      | A             | D           |</span><br><span class="line">| col 2 is      | B             | E           |</span><br><span class="line">| col 1 is      | C             | F           |</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>OMAndroid</title>
    <url>/uncategorized/OMAndroid/</url>
    <content><![CDATA[<h1 id="OMAndroid"><a href="#OMAndroid" class="headerlink" title="OMAndroid"></a>OMAndroid</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OMAndroid 是一个整合了如下主流开源项目的 Android 快速开发框架，其中包括：</p>
<ul>
<li>Dagger</li>
<li>Retrofit  + OkHttp</li>
<li>RxJava</li>
<li>ButterKnife</li>
<li>SqlBrite</li>
<li>EventBus</li>
</ul>
<span id="more"></span>

<p>采用本框架即可使用方便易用的 MVP &amp; Dagger 2 &amp; Retrofit &amp; RxJava 2 的<br>快速开发框架，只需设置简单的参数即可使用。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>包含全局的 Base 基类(<code>BaseApplication</code>、<code>BaseActvity</code>、<code>BaseFragment</code>)；</li>
<li>使用 MVP 架构，使用伴随 Application 全局生命周期的 DataManager 来充当 Model 层，可在不同页面共享数据；</li>
<li>使用注入配置，在不修改框架源码的情况下， 注入 Retrofit,DataBase 等 Config，并且易于扩展；</li>
<li>底层使用 Dagger 连接；</li>
<li>使用多个 Delegate 管理 Application、Activity、Fragment 的生命周期；</li>
<li>使用 ActivityManager 管理所有 Activity，提供方法进行跳转，关闭、存活判断；</li>
<li>还在不断迭代中；</li>
</ul>
<h2 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h2><ul>
<li>结构示意图<br>&#x2F;&#x2F;todo</li>
<li>Module 依赖<ul>
<li>OMAndroid<ul>
<li>示意图<br>  &#x2F;&#x2F;todo</li>
<li>包结构<br>  &#x2F;&#x2F;todo</li>
</ul>
</li>
<li>OMView<ul>
<li>控件介绍</li>
</ul>
</li>
<li>OMDataBase</li>
</ul>
</li>
</ul>
<h2 id="框架使用"><a href="#框架使用" class="headerlink" title="框架使用"></a>框架使用</h2><h3 id="导入框架"><a href="#导入框架" class="headerlink" title="导入框架"></a>导入框架</h3><p>[image:36B64C07-1B86-42CD-93D5-07F12C780B04-5012-0000083442BB302E&#x2F;0C8288FF-B8E8-40B9-9638-D33605E0D5C9.png]<br>在 Android Studio 中导入框架 <code>library</code>及 <code> OMView</code><br>本框架使用了 Lambda 表达式及 Library 中的 ButterKnife 支持，在 Project 的<code>build.gradle</code>中添加如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    classpath &#x27;com.android.tools.build:gradle:3.1.4&#x27;</span><br><span class="line">    classpath &#x27;me.tatarka:gradle-retrolambda:3.7.0&#x27;</span><br><span class="line">    classpath &#x27;com.jakewharton:butterknife-gradle-plugin:8.4.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依赖库设置为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    google()</span><br><span class="line">    mavenCentral()</span><br><span class="line">    jcenter()</span><br><span class="line">    maven &#123; url &quot;https://jitpack.io&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你也想使用 Lambda 表达式，在 <code>app</code> Module 中加入如下代码即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">	  ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后在 <code>app</code> Module 中加入对<code>library</code>的依赖即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    implementation project(&#x27;:omview&#x27;)</span><br><span class="line">	  implementation project(&#x27;:library&#x27;)</span><br><span class="line">	  ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="配置Build-gradle"><a href="#配置Build-gradle" class="headerlink" title="配置Build.gradle"></a>配置<code>Build.gradle</code></h3><p>本框架使用 Dagger 2 依赖，必须配置Dagger 2方可使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    /**</span><br><span class="line">     * dagger</span><br><span class="line">     */</span><br><span class="line">    implementation &#x27;com.google.dagger:dagger:2.15&#x27;</span><br><span class="line">    annotationProcessor &#x27;com.google.dagger:dagger-compiler:</span><br><span class="line">	  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><ol>
<li>配置 Application<br>使用本框架需要继承 OMBaseApplication 并在其 <code>provideApplicationConfig()</code>方法中配置使用中的 Retrofit、数据库等配置。<br>如例子中所示<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public IOMApplicationConfig provideApplicationConfig() &#123;</span><br><span class="line">    return new ApplicationConfiguration();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
编写一个配置文件继承<code>IOMApplicationConfig </code>来配置框架用到的参数，在<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void appleOptions(Context context, ConfigModule.Builder builder)</span><br></pre></td></tr></table></figure>
中设置网络、数据库使用到的参数。可设置的参数详情在<code>library/di/module/ConfigModule</code>中查看。</li>
<li>使用 OMApplicationComponent<br>OMApplicationComponent 中保存了框架中使用的一些单例，可使用<code>OMBaseApplication.getInstanse().getApplicationComponent()</code>获取并使用。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Singleton</span><br><span class="line">@Component(modules = &#123;ApplicationModule.class,ConfigModule.class, NetworkModule.class, DataBaseModule.class&#125;)</span><br><span class="line">public interface OMApplicationComponent &#123;</span><br><span class="line"></span><br><span class="line">    Application application();</span><br><span class="line"></span><br><span class="line">    ActivityManager getActivityManager();</span><br><span class="line"></span><br><span class="line">    IRepositoryManager repositoryManager();</span><br><span class="line"></span><br><span class="line">    PreferencesHelper preferencesHelper();</span><br><span class="line"></span><br><span class="line">    OMActivityLifecycle OMActivityLifecycle();</span><br><span class="line"></span><br><span class="line">    void inject(OMApplicationDelegate delegate);</span><br><span class="line"></span><br><span class="line">    @Component.Builder</span><br><span class="line">    interface Builder &#123;</span><br><span class="line">        @BindsInstance</span><br><span class="line">        Builder application(Application application);</span><br><span class="line">        Builder configModule(ConfigModule configModule);</span><br><span class="line">        OMApplicationComponent build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用 RepositoryManager<br>IRepositoryManager 中提供了获取 Retrofit 的方法，在经过之前<code>IOMApplicationConfig</code>配置过之后，传入 Retrofit 的接口可直接获取到网络请求工具（Retrofit 的具体用法可查阅 <a href="https://github.com/square/retrofit">Retrofit</a>）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Inject</span><br><span class="line">public AccountManager(IRepositoryManager depositoryManager) &#123;</span><br><span class="line">    mDepositoryManager = depositoryManager;</span><br><span class="line">    mAccountApi = mDepositoryManager.obtainRetrofitService(AccountApi.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用 MVP 框架<br>本框架使用伴随 Application 全局生命周期的 DataManager 来充当 Model 层，可在不同页面共享数据，通过 Presenter 直接调用 DataManager 的方法，通过定义 View 与 Presenter 接口实现复用的目的</li>
</ol>
<ul>
<li>使用 Contract<br>Contract 中定义了 View 与 Presenter 之间的协议。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface AccountContract &#123;</span><br><span class="line"></span><br><span class="line">    interface View extends IView &#123;</span><br><span class="line">        void onLoginSuccess(Account account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Presenter extends IPresenter &#123;</span><br><span class="line"></span><br><span class="line">        String getPhone();</span><br><span class="line">        void login(String account, String pwd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用 View<br>使用 Activity 或者 Fragment 来继承 Contract 中定义的 View ，在<code>void initInject()</code>方法中可注入对应定义的 Presenter，并在<code>ActivityComponent</code>中注入该 Activity 即可，如下所示<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void inject(LoginInActivity activity);</span><br></pre></td></tr></table></figure>
（Fragment 同理在<code>FragmentComponent</code> 中注入）；如果页面简单，不实现<code>void initInject()</code>方法即可。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LoginInActivity extends BaseActivity&lt;AccountContract.Presenter&gt; implements AccountContract.View &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void initData(Bundle savedInstanceState) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void initInject() &#123;</span><br><span class="line">        DaggerActivityComponent.builder()</span><br><span class="line">                .managerComponent(DemoApplication.getManagerComponent())</span><br><span class="line">                .activityModule(new ActivityModule(this))</span><br><span class="line">                .build()</span><br><span class="line">                .inject(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int initView(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        return R.layout.fragment_account_login_layout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用 Presenter<br>Presenter 层提供视图与数据层的交互，从下面要介绍的 DataManager 中获取数据进过处理传给 View 层。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AccountPresenter extends BasePresenter&lt;AccountContract.View&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    AccountManager mAccountManager;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    public AccountPresenter() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onAttachView() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDetachView() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用 DataManager<br>在工程中的相同模块的逻辑可以使用相同的 DataManager 来实现数据共享，在工程中，提前生成相应的 DataManager ，在 Presenter 中注入一个或者多个全局的 DataManager 即可使用<ul>
<li>ManagerComponent<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ManagerScope</span><br><span class="line">@Component(dependencies = OMApplicationComponent.class,modules = ManagerModule.class)</span><br><span class="line">public interface ManagerComponent &#123;</span><br><span class="line">    AccountManager accountManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>ManagerModule<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class ManagerModule &#123;</span><br><span class="line"></span><br><span class="line">    Context mContext;</span><br><span class="line"></span><br><span class="line">    public ManagerModule(Context context) &#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Provides</span><br><span class="line">    @ManagerScope</span><br><span class="line">    AccountManager provideAccountManager(IRepositoryManager repositoryManager,PreferencesHelper preferencesHelper)&#123;</span><br><span class="line">        return new AccountManager(repositoryManager,preferencesHelper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="其他功能介绍"><a href="#其他功能介绍" class="headerlink" title="其他功能介绍"></a>其他功能介绍</h3><ol>
<li><p>OMLog<br>在程序中可使用 <code>Logx.v/i/d/w/e</code>来打印 Log，支持 String、@StrRes、Json，当需要自定义 tag 时，可以使用 <code>Logx.tag(TAG).v/i/d/w/e</code>来使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Logx.tag(TAG).w(&quot;mActivityList == null when killActivity(Class)&quot;);</span><br><span class="line">Logx.d(&quot;build database &quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Toast<br>使用 Toastx 来显示 Toast 消息，Toast 内部已做好视图复用，当多次调用 Toast 消息时不会连续弹消息，只会保留最后一次的消息，提升用户体验。<br>Toastx 还支持两种视图布局：默认的 Toast 与显示在屏幕中间黑色背景的 Toast。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Toastx.show(&quot;已复制到剪贴板&quot;);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>OMAndroid</tag>
      </tags>
  </entry>
  <entry>
    <title>int 与 Integer</title>
    <url>/Java/int-%E4%B8%8E-Integer/</url>
    <content><![CDATA[<ul>
<li>Integer是int的包装类，int则是java的一种基本数据类型</li>
<li>Integer变量必须实例化后才能使用，而int变量不需要</li>
<li>Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值</li>
<li>Integer的默认值是null，int的默认值是0</li>
</ul>
<span id="more"></span>


<h2 id="关于int和Integer的值的比较"><a href="#关于int和Integer的值的比较" class="headerlink" title="关于int和Integer的值的比较"></a>关于int和Integer的值的比较</h2><ul>
<li>两个通过new生成的Integer变量永远是不相等的。因为 new 出来的对象永远是两个对象，内存地址不同。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer i = new Integer(100);</span><br><span class="line">Integer j = new Integer(100);</span><br><span class="line">System.out.print(i == j); //false</span><br></pre></td></tr></table></figure>
<ul>
<li>非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer i = new Integer(100);</span><br><span class="line">Integer j = 100;</span><br><span class="line">System.out.print(i == j); //false</span><br></pre></td></tr></table></figure>
<ul>
<li>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false。因为在Integer 自动装箱的时候会调用<code>Integer valueOf(int i)</code>函数，判断值是否在缓冲区内。自动装箱请看后文。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer i = 100;</span><br><span class="line">Integer j = 100;</span><br><span class="line">System.out.print(i == j); //true</span><br><span class="line"></span><br><span class="line">Integer i = 128;</span><br><span class="line">Integer j = 128;</span><br><span class="line">System.out.print(i == j); //false</span><br></pre></td></tr></table></figure>

<h2 id="int-和-Integer-应用中具体会产生哪些差异"><a href="#int-和-Integer-应用中具体会产生哪些差异" class="headerlink" title="int 和 Integer 应用中具体会产生哪些差异"></a>int 和 Integer 应用中具体会产生哪些差异</h2><p>int 是直接存储在堆内存中的，大量使用对象类型会消耗大量的系统资源。int 在性能极度敏感的场景往往具有比较大的优势。</p>
<h2 id="Integer-的源码分析"><a href="#Integer-的源码分析" class="headerlink" title="Integer 的源码分析"></a>Integer 的源码分析</h2><h3 id="缓冲区的调整"><a href="#缓冲区的调整" class="headerlink" title="缓冲区的调整"></a>缓冲区的调整</h3><p>JVM 提供了参数设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:AutoBoxCacheMax=N</span><br></pre></td></tr></table></figure>

<h3 id="Integer-的数值保存"><a href="#Integer-的数值保存" class="headerlink" title="Integer 的数值保存"></a>Integer 的数值保存</h3><p>Integer 保存相应的数值时的变量是一个 final 变量，这是为了保证在使用的时候内存地址不变的情况下值也不会发生变化。</p>
<h2 id="关于-int-和-Integer-的问题区别分析"><a href="#关于-int-和-Integer-的问题区别分析" class="headerlink" title="关于 int 和 Integer 的问题区别分析"></a>关于 int 和 Integer 的问题区别分析</h2><h3 id="自动装箱-x2F-自动拆箱"><a href="#自动装箱-x2F-自动拆箱" class="headerlink" title="自动装箱&#x2F;自动拆箱"></a>自动装箱&#x2F;自动拆箱</h3><ul>
<li>自动装箱时编译器调用 valueOf() 将原始类型值转换成对象，同时自动拆箱时，编译器通过调用类似intValue(),doubleValue()这类的方法将对象转换成原始类型值。</li>
<li>自动装箱是将boolean值转换成Boolean对象，byte值转换成Byte对象，char转换成Character对象，float值转换成Float对象，int转换成Integer，long转换成Long，short转换成Short，自动拆箱则是相反的操作。</li>
</ul>
<p>自动装箱&#x2F;拆箱是发生在编译阶段，当接受的一个原始类型值，那么Java 会自动将这个原始类型值转换为与之对应的对象，反之拆箱亦然。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>原始数据类型并不能保证县城安全，要保证多线程安全必须使用类似 AtomicInteger、AtomicLong 这样的线程安全类。</p>
<h3 id="AtomicInteger-的实现"><a href="#AtomicInteger-的实现" class="headerlink" title="AtomicInteger 的实现"></a>AtomicInteger 的实现</h3><ul>
<li>AtomicInteger类中有有一个变量valueOffset，用来描述AtomicInteger类中value的内存位置 。</li>
<li>当需要变量的值改变的时候，先通过get（）得到valueOffset位置的值，也即当前value的值.给该值进行增加，并赋给next</li>
<li>compareAndSet（）比较之前取到的value的值当前有没有改变，若没有改变的话，就将next的值赋给value，倘若和之前的值相比的话发生变化的话，则重新一次循环，直到存取成功，通过这样的方式能够保证该变量是线程安全的</li>
<li>value使用了volatile关键字，使得多个线程可以共享变量，使用volatile将使得VM优化失去作用，在线程数特别大时，效率会较低。</li>
</ul>
<h2 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h2><p>Java 的原始数据类型并不能与泛型搭配使用，因为Java 的泛型是一种在编译阶段会自动将类型转换为对应的特定类型，这就决定了使用泛型，必须保证相应类型可以转换为 Object。而原始数据类型并不是对象类型。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>try、catch、finally、throw和throws</title>
    <url>/Java/try%E3%80%81catch%E3%80%81finally%E3%80%81throw%E5%92%8Cthrows/</url>
    <content><![CDATA[<p>try、catch、finally 是 Java 中处理异常的一套机制。</p>
<span id="more"></span>

<p>完整的代码流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    //尝试执行的代码</span><br><span class="line">&#125; catch (Exception e)&#123;</span><br><span class="line">    //捕获的异常</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    //最后总是会执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 try 代码块中执行尝试的代码，在 catch 中捕获可能在 try 代码块会出现的异常并做相应的处理，最后在 finally 代码块执行总会执行的代码。这是简单的行文，当在这些代码块中出现了 return 时会按照什么顺序执行呢？</p>
<ol>
<li>在不抛出异常的情况下，程序执行完 try 里面的代码块之后，该方法并不会立即结束，而是继续试图去寻找该方法有没有 finally 的代码块；</li>
<li>如果没有 finally 代码块，整个方法在执行完 try 代码块后返回相应的值来结束整个方法；</li>
<li>如果有 finally 代码块，此时程序执行到 try 代码块里的 return 语句之时并不会立即执行 return，而是先去执行 finally 代码块里的代码；</li>
<li>若 finally 代码块里没有 return 或没有能够终止程序的代码，程序将在执行完 finally 代码块代码之后再返回 try 代码块执行 return 语句来结束整个方法；</li>
<li>若 finally 代码块里有 return 或含有能够终止程序的代码，方法将在执行完 finally 之后被结束，不再跳回 try 代码块执行 return；</li>
</ol>
<p>有异常时将上述 try 代码块替换成 catch 即可。</p>
<p>当程序遇见 <code>System.exit(0);</code> 时不管执行到什么地方都会立即执行推出当前进程。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 Context 的二三事</title>
    <url>/Android/%E5%85%B3%E4%BA%8E-Context-%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<p>Context 是Android 开发处处可见的一个对象，这些对象是怎么来的，有什么关系，怎么使用，这里学习记录一下。</p>
<span id="more"></span>

<p><img src="http://img.artaris.cn/15564663949291.jpg"></p>
<p>Context是一个抽象基类，我们通过它访问当前包的资源（getResources、getAssets）和启动其他组件（Activity、Service、Broadcast）以及得到各种服务（getSystemService）。</p>
<p>对Context的理解可以来说：Context提供了一个应用的运行环境，在Context的大环境里，应用才可以访问资源，才能完成和其他组件、服务的交互，Context定义了一套基本的功能接口，我们可以理解为一套规范，而Activity和Service是实现这套规范的子类，这么说也许并不准确，因为这套规范实际是被ContextImpl类统一实现的，Activity和Service只是继承并有选择性地重写了某些规范的实现。</p>
<p><strong>Activity在创建的时候会new一个ContextImpl对象并在attach方法中关联它</strong></p>
<p>很明确，不同的Context得到的都是同一份资源。这是很好理解的，请看下面的分析，<br>在设备参数和显示参数不变的情况下，不同的ContextImpl访问到的是同一份资源。设备参数不变是指手机的屏幕和android版本不变，显示参数不变是指手机的分辨率和横竖屏状态。也就是说，尽管Application、Activity、Service都有自己的ContextImpl，并且每个ContextImpl都有自己的mResources成员，但是由于它们的mResources成员都来自于唯一的ResourcesManager实例，所以它们看似不同的mResources其实都指向的是同一块内存(C语言的概念)，因此，它们的mResources都是同一个对象（在设备参数和显示参数不变的情况下）。</p>
<p><img src="http://img.artaris.cn/15564659341006.jpg"></p>
<p><strong>getApplication()和getApplicationContext()的区别？</strong><br>getApplication返回结果为Application，且不同的Activity和Service返回的Application均为同一个全局对象，在ActivityThread内部有一个列表专门用于维护所有应用的application<br>getApplicationContext返回的也是Application对象，只不过返回类型为Context，看看它的实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override  </span><br><span class="line">public Context getApplicationContext() &#123;  </span><br><span class="line">    return (mPackageInfo != null) ?  </span><br><span class="line">            mPackageInfo.getApplication():mMainThread.getApplication();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>上面代码中mPackageInfo是包含当前应用的包信息、比如包名、应用的安装目录等，原则上来说，作为第三方应用，包信息mPackageInfo不可能为空，在这种情况下，getApplicationContext返回的对象和getApplication是同一个。但是对于系统应用，包信息有可能为空，具体就不深入研究了。从这种角度来说，对于第三方应用，一个应用只存在一个Application对象，且通过getApplication和getApplicationContext得到的是同一个对象，两者的区别仅仅是返回类型不同。</p>
<p><strong>Context 导致的内存泄漏问题？</strong><br>ApplicationContext 会伴随应用的整个生命周期，不会泄漏。Context 泄漏基本都指ActivityContext 。<br>当把Context传入第三方类时，这个类就持有了这个 Activity 这个对象，当Activity销毁的时候，可能这个对象还在使用中（如工具类、Presenter 等）造成Activity无法正常回收，即内存泄漏。</p>
<p><strong>正确使用 Context 的姿势？</strong></p>
<ol>
<li>与视图有关的上下文，尽量使用Activity Context，不去使用ApplicationContext 去创建新的页面（setFlag(FLAG_NEW_TASK|FLAG_CLEAN_TOP)）会开辟一个新的页面栈，不方便管理。</li>
<li>在初始化工具类的时候，使用getApplicaitonContext()去初始化，不会造成内存泄漏。</li>
<li>Application Context 在 attachBaseContext()之后才会初始化。执行顺序为<code>Constructor()</code>-&gt;<code>attachBaseContext()</code>-&gt;<code>onCreate()</code></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>[北京]出闲置</title>
    <url>/uncategorized/%E5%8C%97%E4%BA%AC-%E5%87%BA%E9%97%B2%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="【北京】出闲置-坚果Pro2-一加3T-PS4-小米电视-紫米无线充电器-机械键盘-等，收二手-MIX-2S"><a href="#【北京】出闲置-坚果Pro2-一加3T-PS4-小米电视-紫米无线充电器-机械键盘-等，收二手-MIX-2S" class="headerlink" title="【北京】出闲置[坚果Pro2][一加3T][PS4][小米电视][紫米无线充电器][机械键盘]等，收二手[MIX 2S]"></a>【北京】出闲置[坚果Pro2][一加3T][PS4][小米电视][紫米无线充电器][机械键盘]等，收二手[MIX 2S]</h1><p>以下东西北京均可面交，外地走闲鱼(电视除外)。</p>
<p>电视就只北京吧，外地不考虑了，弄个货拉拉给你送过去了。</p>
<span id="more"></span>

<h3 id="1、坚果-Pro-2-（1000元）"><a href="#1、坚果-Pro-2-（1000元）" class="headerlink" title="1、坚果 Pro 2 （1000元）"></a>1、坚果 Pro 2 （1000元）</h3><p>炭黑色（细红线版） 4+64，有磨损，正常使用痕迹。</p>
<p>17年11月购于京东，有原装盒及发票，正常使用痕迹。送两个清水套。</p>
<p>买来尝鲜，没有剧烈使用过，玩腻了就出了，机器手感、屏幕显示效果都挺好的，没有暗病。我主力机 iPhone 不能双卡，这个我一直插副卡收个验证码什么的，用着都挺好的。</p>
<p><img src="http://img.artaris.cn/sell/img-1-1.jpg?imageMogr2/thumbnail/!30p"><br><img src="http://img.artaris.cn/sell/img-1-2.jpg?imageMogr2/thumbnail/!30p"></p>
<h3 id="2、一加-3T-（500元）"><a href="#2、一加-3T-（500元）" class="headerlink" title="2、一加 3T （500元）"></a>2、一加 3T （500元）</h3><p>深空灰色 6+64，多处磨损，屏幕右上角磕碎，不影响使用（具体看图），已刷 <a href="http://www.mokeedev.com/">魔趣</a> 8.1.0 类原生系统，你要不喜欢我可以刷成 氢OS&#x2F;氧OS&#x2F;Lineage OS 再发给你。</p>
<p>17年初购于京东，有购物记录，无盒子，带一套原装 Dash 闪充。</p>
<p>一直在我手下做开发机，没当过主力机，电池什么的你不要太认真，因为我也没认真测过。</p>
<p><img src="http://img.artaris.cn/sell/img-2-1.jpg?imageMogr2/thumbnail/!30p"><br><img src="http://img.artaris.cn/sell/img-2-2.jpg?imageMogr2/thumbnail/!30p"></p>
<h3 id="3、PS4-（1000元）"><a href="#3、PS4-（1000元）" class="headerlink" title="3、PS4 （1000元）"></a>3、PS4 （1000元）</h3><p>PlayStation 500G 国行，这东西没啥磨损，就是落灰了。</p>
<p>15年双十一购于天猫，有购物记录，有原装盒子、原装手柄，还有我自己买的一个支架（具体看图）。</p>
<p>我自己买了一个白的手柄，购于天猫，也有购物记录，要想一起要 200 拿去，无包装。</p>
<p><img src="http://img.artaris.cn/sell/img-3-1.jpg?imageMogr2/thumbnail/!30p"><br><img src="http://img.artaris.cn/sell/img-3-2.jpg?imageMogr2/thumbnail/!30p"></p>
<h3 id="4、小米电视4A-49’-（1400元）"><a href="#4、小米电视4A-49’-（1400元）" class="headerlink" title="4、小米电视4A 49’ （1400元）"></a>4、小米电视4A 49’ （1400元）</h3><p><a href="https://www.mi.com/mitv4A/49/">小米电视4A</a> 屏幕完好，也没有磨损。</p>
<p>17年中购于小米之家当代商城店，有购物记录，有原装遥控器，+送我自己配的壁挂。</p>
<p>成色非常好，担心或想具体了解的可以+V信发视频给你。</p>
<p><img src="http://img.artaris.cn/sell/img-4-1.jpg?imageMogr2/thumbnail/!30p"><br><img src="http://img.artaris.cn/sell/img-4-2.jpg?imageMogr2/thumbnail/!30p"></p>
<h3 id="5、紫米无线充电器-（80元）"><a href="#5、紫米无线充电器-（80元）" class="headerlink" title="5、紫米无线充电器 （80元）"></a>5、紫米无线充电器 （80元）</h3><p><a href="https://item.jd.com/7731665.html">紫米无线充电器</a> 白色，全新无磨损。</p>
<p>几个月前购于天猫，有购物记录，带原装的充电头及 Type-C 线。</p>
<p>我买了一黑一白俩，本来是想给 iPhone 充电的，无奈充电速度确实不快，我就留一个放公司用出一个吧，我一直用的是黑色的，白色就拆了封，黑的其实也没啥磨损。你要喜欢黑的也可以卖黑的给你，不过都一个价。</p>
<p><img src="http://img.artaris.cn/sell/img-5-1.jpg?imageMogr2/thumbnail/!30p"><br><img src="http://img.artaris.cn/sell/img-5-2.jpg?imageMogr2/thumbnail/!30p"></p>
<h3 id="6、机械键盘-iQuix-Lambo-62"><a href="#6、机械键盘-iQuix-Lambo-62" class="headerlink" title="6、机械键盘 iQuix Lambo 62"></a>6、机械键盘 iQuix Lambo 62</h3><p><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-16280822950.30.199262cdXATbHN&id=532918030708">iQuix Lambo 62</a> 机械键盘，红色茶轴，铝合金底座，红底黑色键帽侧刻，具体成色可看图。</p>
<p>16年双十一购于天猫期间，带原装 Mini-USB 连接线。</p>
<p>附一个<a href="http://www.inwaishe.com/article-3144-1.html">测评链接</a></p>
<p>换了 MacBook Pro 没有 USB-A 接口了，天天拖着一堆线很烦躁，想入一个迷你啦蓝牙，故出这个，不过也不着急出，毕竟又不是不能用(･ェ･。)，所以不要压价⊙﹏⊙|||。</p>
<p><img src="http://img.artaris.cn/sell/img-6-1.jpg?imageMogr2/thumbnail/!30p"><br><img src="http://img.artaris.cn/sell/img-6-2.jpg?imageMogr2/thumbnail/!30p"></p>
<h3 id="7、一代-Apple-Macgic-TrackPad"><a href="#7、一代-Apple-Macgic-TrackPad" class="headerlink" title="7、一代 Apple Macgic TrackPad"></a>7、一代 Apple Macgic TrackPad</h3><p>Apple Macgic TrackPad，无明显磨损，具体成色可看图。</p>
<p>14年初购于京东，有原装盒子和发票。</p>
<p>当时买了 Magic Mouse 和 TrackPad，用了用还是喜欢 Mouse，TrackPad就吃了灰，现在真是没什么用了，一起出了。</p>
<p><img src="http://img.artaris.cn/sell/img-7-1.jpg?imageMogr2/thumbnail/!30p"><br><img src="http://img.artaris.cn/sell/img-7-2.jpg?imageMogr2/thumbnail/!30p"></p>
<h2 id="收小米MIX2s"><a href="#收小米MIX2s" class="headerlink" title="收小米MIX2s"></a>收小米MIX2s</h2><p>顺带收个小米 MIX 2s ，要求成色无破损，屏幕正常使用痕迹即可，心理价位2000元，配置颜色可视具体情况。</p>
<p>可加微信 QXJ0YXJpc0NO (base64) 详聊。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——二叉树</title>
    <url>/uncategorized/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>树形结构的基本概念：</p>
<ul>
<li><strong>根节点</strong>：</li>
<li><strong>度</strong>：结点拥有的直接子节点数称为<strong>结点的度</strong></li>
<li><strong>叶子</strong>：度为0的结点称为<strong>叶子</strong></li>
<li><strong>树的度</strong>：所有结点的度中的最大值</li>
<li><strong>孩子</strong>：一个结点的直接子结点称为它的<strong>孩子</strong></li>
<li><strong>双亲</strong>：一个节点的父节点就是他的双亲节点</li>
<li><strong>深度</strong>：树中最大的结点层</li>
</ul>
<span id="more"></span>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>一个结点的直接子节点最多只能有两个，并且有左右之分，次序不能随意颠倒。</p>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><ol>
<li>所有分支结点的度为２；</li>
<li>所有叶子结点只能分布在最下层上；</li>
<li>同样深度的二叉树中，满二叉树的结点数最多，叶子结点数最多；</li>
</ol>
<ul>
<li>满二叉树的深度：log2(n+1)；</li>
</ul>
<h4 id="完全二叉树（只有最底下一层不满的满二叉树）"><a href="#完全二叉树（只有最底下一层不满的满二叉树）" class="headerlink" title="完全二叉树（只有最底下一层不满的满二叉树）"></a>完全二叉树（只有最底下一层不满的满二叉树）</h4><ol>
<li>二叉树从根结点出发，按着层次从左到右遍历，第i个结点的位置与满二叉树中对应结点位置完全相同；</li>
<li>所有叶子结点只能出现在最下两层；</li>
<li>若结点度为1，则该结点只有左子树，不存在只有右子树的情况；</li>
<li>结点分配<code>先左后右</code>；</li>
</ol>
<h4 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h4><ol>
<li>先序遍历：先访问根节点；先序遍历左子树；先序遍历右子树；</li>
<li>中序遍历：中序遍历左子树；访问根节点；中序遍历右子树；</li>
<li>后序遍历：后序遍历左子树；后序遍历右子树；访问根节点；</li>
</ol>
<p>先序遍历——前缀表示——波兰式<br>后序遍历——后缀表示——逆波兰式</p>
<h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><p>增加节点的左右指针一个标志位：是否为叶子节点。当为叶子节点的时候，其左右指针指向其某种遍历的前驱、后驱；否则指向其左右子树。</p>
<ul>
<li><strong>线索</strong>：指向节点前驱与后驱的指针叫做<strong>线索</strong></li>
<li><strong>线索化</strong>：以某种次序遍历使其变为线索二叉树的过程</li>
</ul>
<h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><p>二叉排序树又称二叉查找树，亦称二叉搜索树，它主要用于查找。 它或者是一棵空树；或者是具有下列性质的二叉树：<br>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>（3）左、右子树也分别为二叉排序树；</p>
<p>中序遍历二叉排序树可得到其有序序列，讲一个无序序列变为二叉排序树是一个排序过程。</p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树又被称为AVL树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，由它可以生成平衡二叉搜索树，查找效率会更高。构造与调整方法平衡二叉树的常用算法有红黑树、AVL、Treap等。最小二叉平衡树的节点的公式如下F(n)&#x3D;F(n-1)+F(n-2)+1这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。</p>
<ul>
<li><strong>平衡因子</strong>：左子树的深度减去右子树的深度<br>平衡二叉树的平衡因子只会是-1，0，1</li>
<li>在结点的左子树的左子树插入元素,LL 插入；<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwzn333ggzj30k405gaax.jpg"></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 右旋（顺时针旋转）</span><br><span class="line"> *</span><br><span class="line"> * @param node 失衡结点</span><br><span class="line"> * @return 旋转后根节点</span><br><span class="line"> */</span><br><span class="line">private TreeNode&lt;T&gt; rightRotate(TreeNode&lt;T&gt; node) &#123;</span><br><span class="line">    // 将失衡结点的左子树赋给一个临时结点，也就是将A的左子树B 赋给新的结点</span><br><span class="line">    TreeNode&lt;T&gt; newRoot = node.leftChild;</span><br><span class="line">    // 将B 被右子树BR 挂在A 的左子树上</span><br><span class="line">    node.leftChild = newRoot.rightChild;</span><br><span class="line">    // B 的右子树为失衡的结点即A</span><br><span class="line">    newRoot.rightChild = node;</span><br><span class="line">    // 结点A 的高度为左右子树高度最大值加1</span><br><span class="line">    node.height = getMax(height(node.leftChild), height(node.rightChild)) + 1;</span><br><span class="line">    // 结点B 的高度为左右子树高度最大值加1</span><br><span class="line">    newRoot.height = getMax(height(newRoot.leftChild), newRoot.height) + 1;</span><br><span class="line">    // 返回根节点</span><br><span class="line">    return newRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在结点的左子树的右子树插入元素,LR 插入；</li>
<li>在结点的右子树的左子树插入元素,RL 插入；</li>
<li>在结点的右子树的右子树插入元素,RR 插入。</li>
</ul>
<ol>
<li>如上所述的第3步，当插入元素后导致左边高，右边低，并且为4和3的平衡因子符号相同，则右旋。</li>
<li>如上所诉的第5步，当插入节点9后，导致以4为根的树右边高，左边低，4和7的平衡因子符号相同，则左旋</li>
<li>如上所述的第7步，当插入节点10后，导致以9为根的树右边高，左边低，由于9和11的平衡因子符号不同（也就是根和他的右孩子的平衡因子符号不同）不能进行左旋，正确操作：需要先右旋在左旋，要让根和根的右孩子平衡因子符号相同。</li>
<li>第4种旋转和3相反，当左边高于右边的话，且根和他的左孩子，平衡因子符号不同，需要先左旋再右旋</li>
</ol>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>哈夫曼树也称最优二叉树，它是带权路径长度最小的二叉树。</p>
<p>哈夫曼树的构造规则为：<br>(1) 将w1、w2、…、wn看成是有n 棵树的集合(每棵树仅有一个结点)；<br>(2) 在集合中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；<br>(3)从集合中删除选取的两棵树，并将新树加入集合；<br>(4)重复(2)、(3)步，直到集合中只剩一棵树为止，该树即为所求得的哈夫曼树。</p>
<p><strong>为了使得到的哈夫曼树的结构尽量唯一，通常规定生成的哈夫曼树中每个结点的左子树根结点的权小于等于右子树根结点的权。</strong></p>
<h5 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h5><p>电文是以二进制的0、1序列传送的，每个字符对应一个二进制编码，为了缩短电文的总长度，采用不等长编码方式，构造哈夫曼树，<br>将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码，从树根结点到每个叶子结点的路径上</p>
<h4 id="B-树、B-树"><a href="#B-树、B-树" class="headerlink" title="B 树、B+ 树"></a>B 树、B+ 树</h4><p>这里的B树，也就是英文中的B-Tree，一个 m 阶的B树满足以下条件：</p>
<ol>
<li>每个结点至多拥有m棵子树；</li>
<li>根结点至少拥有两颗子树（存在子树的情况下）；</li>
<li>除了根结点以外，其余每个分支结点至少拥有 m&#x2F;2 棵子树；</li>
<li>所有的叶结点都在同一层上；</li>
<li>有 k 棵子树的分支结点则存在 k-1 个关键码，关键码按照递增次序进行排列；</li>
<li>关键字数量需要满足ceil(m&#x2F;2)-1 &lt;&#x3D; n &lt;&#x3D; m-1；</li>
</ol>
<h4 id="红黑树RBTree"><a href="#红黑树RBTree" class="headerlink" title="红黑树RBTree"></a>红黑树<em>RBTree</em></h4><ol>
<li>每个节点要么是黑的，要么是红的</li>
<li>根节点是黑的</li>
<li>叶节点是黑的</li>
<li>如果一个节点是红的，他的两个儿子节点都是黑的</li>
<li>对于任一节点而言，其到叶节点树尾端NIL指针的每一条路径都包含相同数目的黑节点</li>
<li>新插入的节点总是设为红色的</li>
</ol>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——排序</title>
    <url>/uncategorized/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">时间复杂度</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入排序</td>
<td align="center">O(n2)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">O(n2)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">冒泡排序</td>
<td align="center">O(n2)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(nLog2n)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(nLog2n)</td>
<td align="center">O(nLog2n)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(nLog2n)</td>
<td align="center">(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">O(n1.5)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">O(n)</td>
<td align="center">O(n)</td>
<td align="center">不稳定</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>直接插入排序的核心思想就是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过。<br>因此，从上面的描述中我们可以发现，直接插入排序可以用两个循环完成：</p>
<ol>
<li>第一层循环：遍历待比较的所有数组元素</li>
<li>第二层循环：将本轮选择的元素(selected)与已经排好序的元素(ordered)相比较。找到它应该在有序队列的位置之后，将二者交换。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void insertSort(int[] num) &#123;</span><br><span class="line">    if (num == null || num.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; num.length; i++) &#123;</span><br><span class="line">        int v = num[i], j;</span><br><span class="line">        for (j = i; j &gt; 0 &amp;&amp; v &lt; num[j - 1]; j--) &#123;</span><br><span class="line">            num[j] = num[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        num[j] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序是一直非常直观的选择办法，它每次寻找当前未排序列表中最大（小）的数，放在队列的首（尾），然后从未排序的队列中取出，再找剩下队列的最值。经过<code>n-1</code>次循环排序完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void selectSort(int[] num) &#123;</span><br><span class="line">    if (num == null || num.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; num.length - 1; i++) &#123;</span><br><span class="line">        int min = i, temp;</span><br><span class="line">        for (int j = num.length - 1; j &gt; i; j--) &#123;</span><br><span class="line">            if (num[j] &lt; num[min]) &#123;</span><br><span class="line">            min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = num[min];</span><br><span class="line">        num[min] = num[i];</span><br><span class="line">        num[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是一种简单的排序算法，他依次的检查要排序的数列，每次比较两个数，如果他们顺序有误就把他们调换过来，经过依次走访，有一个最大（最小）的数据就会落座，经过<code>n-1</code>次循环排序完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void bubbleSort(int[] num) &#123;</span><br><span class="line">    if (num == null || num.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; num.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; num.length - i; j++) &#123;</span><br><span class="line">            if (num[j] &gt; num[j + 1]) &#123;</span><br><span class="line">                num[j + 1] = num[j + 1] + num[j];</span><br><span class="line">                num[j] = num[j + 1] - num[j];</span><br><span class="line">                num[j + 1] = num[j + 1] - num[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是基于归并操作的一种排序算法，即将两个已经排好序的数组合并成一个序列的操作。<br>对于使用时，使用了分治方法，即将数组递归分割成两两等分，比较再进行合并。使用时需要注意边界数据处理。<br>每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。<br>迭代方法即将步长从1增加至 n.length &#x2F; 2 ,分组排序及合并。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void mergeSort(int[] num) &#123;</span><br><span class="line">    if (num == null || num.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    merge(num, 0, num.length - 1, new int[num.length]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void merge(int[] num, int start, int end, int[] temp) &#123;</span><br><span class="line">    if (start &lt; end) &#123;</span><br><span class="line">        int mid = (end + start) / 2;</span><br><span class="line">        merge(num, start, mid, temp);</span><br><span class="line">        merge(num, mid + 1, end, temp);</span><br><span class="line">        mergeArray(num, start, mid, end, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void mergeArray(int[] num, int start, int mid, int end, int[] temp) &#123;</span><br><span class="line">    int i = start, j = mid + 1;</span><br><span class="line">    int k = 0;</span><br><span class="line"></span><br><span class="line">    while (i &lt;= mid &amp;&amp; j &lt;= end) &#123;</span><br><span class="line">        if (num[i] &lt; num[j])</span><br><span class="line">            temp[k++] = num[i++];</span><br><span class="line">        else if (num[i] == num[j])</span><br><span class="line">            temp[k++] = num[i++];</span><br><span class="line">        else</span><br><span class="line">            temp[k++] = num[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (i &lt;= mid)</span><br><span class="line">        temp[k++] = num[i++];</span><br><span class="line"></span><br><span class="line">    while (j &lt;= end)</span><br><span class="line">        temp[k++] = num[j++];</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; k; i++)</span><br><span class="line">        num[start + i] = temp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序（Quicksort）是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void quickSort(int[] num) &#123;</span><br><span class="line">    if (num == null || num.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _quickSort(num, 0, num.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void _quickSort(int[] num, int start, int end) &#123;</span><br><span class="line">    if (start &gt;= end)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    int t = num[start]，i = start, j = end;</span><br><span class="line"></span><br><span class="line">    while (j != i) &#123;</span><br><span class="line">        while (j &gt; i &amp;&amp; num[j] &gt;= t)</span><br><span class="line">            j--;</span><br><span class="line"></span><br><span class="line">        while (j &gt; i &amp;&amp; num[i] &lt;= t)</span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">        if (i &lt; j) &#123;</span><br><span class="line">            int temp = num[j];</span><br><span class="line">            num[j] = num[i];</span><br><span class="line">            num[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp = num[i];</span><br><span class="line">    num[i] = num[start];</span><br><span class="line">    num[start] = temp;</span><br><span class="line"></span><br><span class="line">    _quickSort(num, start, i - 1);</span><br><span class="line">    _quickSort(num, i + 1, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是根据堆的原理——堆是一个完全二叉树，切如大顶堆，每个父节点的值都大于他的子节点，当一个已经构造完成的大顶堆，每次将堆顶的数据与最后一个值调换，再将剩余的数据重新排列成一个大顶堆，重复这个过程，就构排序完成了。则问题变成了构造大顶堆及调换数字再构造的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void heapSort(int[] num) &#123;</span><br><span class="line">    if (num == null || num.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = num.length / 2 - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        //构造大顶堆，初始化</span><br><span class="line">        buildMaxHeap(num, i, num.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = num.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        //交换堆顶与最后一位字符的顺序</span><br><span class="line">        num[i] = num[i] + num[0];</span><br><span class="line">        num[0] = num[i] - num[0];</span><br><span class="line">        num[i] = num[i] - num[0];</span><br><span class="line"></span><br><span class="line">        //对剩下的数据继续构造大顶堆</span><br><span class="line">        buildMaxHeap(num, 0, i - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void buildMaxHeap(int[] num, int start, int end) &#123;</span><br><span class="line">    //father 为要构造的分支的父节点，son为父节点的左子树</span><br><span class="line">    int father = start, son = start * 2 + 1;</span><br><span class="line">    //son 为寻找最大数值的指针，从左子树的根节点开始，到末尾为止</span><br><span class="line">    while (son &lt;= end) &#123;</span><br><span class="line">        //如果当前指针不如根节点大，则指向右节点</span><br><span class="line">        if (son + 1 &lt; end &amp;&amp; num[son] &lt; num[son + 1]) &#123;</span><br><span class="line">            son++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (num[father] &lt;= num[son]) &#123;</span><br><span class="line">            //若根节点比左右子树都大，直接返回，否则交换根节点与左右子树的值,因为比较时是从最后一个非叶子节点开始的，所以直接比较根节点与左右子树就可以</span><br><span class="line">            num[father] = num[father] + num[son];</span><br><span class="line">            num[son] = num[father] - num[son];</span><br><span class="line">            num[father] = num[father] - num[son];</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。<br>步骤为</p>
<ul>
<li>先按照步长为一遍数组的长度，分组，进行插入排序；</li>
<li>缩小步长为刚才的一半，继续分组排序；</li>
<li>直到步长为1时经过一遍排序完成；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void shellSort(int[] num) &#123;</span><br><span class="line">    if (num == null || num.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //步长为初始数组长度的一半，最短为1</span><br><span class="line">    for (int gap = num.length / 2; gap &gt; 0; gap /= 2) &#123;</span><br><span class="line">        for (int i = gap; i &lt; num.length; i++) &#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            //冒泡排序</span><br><span class="line">            while (j - gap &gt; 0 &amp;&amp; num[j] &lt; num[j - gap]) &#123;</span><br><span class="line">                num[j] = num[j] + num[j - gap];</span><br><span class="line">                num[j - gap] = num[j] - num[j - gap];</span><br><span class="line">                num[j] = num[j] - num[j - gap];</span><br><span class="line">                j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序是一种以空间换时间的排序方法，事先要知道待排序数组的范围，申请一个空间为待排序数组最大值减去最小值的记录数组，然后依次遍历数组，出现某个数则标记相应位置+1，全部遍历完成再从小到大遍历记录数组，输出出现次数即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">int</span>[] num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE, min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : num) &#123;</span><br><span class="line">        max = Math.max(max, i);</span><br><span class="line">        min = Math.min(min, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : num) &#123;</span><br><span class="line">        bucket[i - min]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (bucket[i]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            num[index++] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——栈和队列</title>
    <url>/uncategorized/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>栈和队列是线性表的一种，只是它们是操作受限的线性表。</p>
<span id="more"></span>

<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈是只能在表尾进行插入或删除操作的线性表，通常我们称表尾端为栈顶，表头端为栈底，它是一种先进后出的线性表，既只能在表尾端插入元素，称为入栈，也只能在表尾端删除元素，称为出栈。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">↳     java.util.AbstractCollection&lt;E&gt;</span><br><span class="line">   ↳     java.util.AbstractList&lt;E&gt;</span><br><span class="line">       ↳     java.util.Vector&lt;E&gt;</span><br><span class="line">           ↳     java.util.Stack&lt;E&gt;</span><br><span class="line"></span><br><span class="line">public class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Stack的API"><a href="#Stack的API" class="headerlink" title="Stack的API"></a>Stack的API</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             boolean       empty()              // 栈是否为空</span><br><span class="line">synchronized E             peek()               // 返回栈顶元素，不执行删除操作</span><br><span class="line">synchronized E             pop()                // 返回栈顶元素，并将其从栈中删除</span><br><span class="line">             E             push(E object)       // 将元素存入栈顶</span><br><span class="line">synchronized int           search(Object o)     // 查找“元素o”在栈中的位置：由栈底向栈顶方向数</span><br></pre></td></tr></table></figure>

<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列刚好和栈相反，它是一种先进先出（FIFO）的线性表，只能在一端插入元素，在另一端删除元素，如下图所示，允许插入元素的一端称为队尾，允许删除元素的一端称为队头。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Iterable&lt;E&gt;</span><br><span class="line">↳     java.util.Collection&lt;E&gt;</span><br><span class="line">   ↳     java.util.Stack&lt;E&gt;</span><br><span class="line"></span><br><span class="line">public interface Queue&lt;E&gt; extends Collection&lt;E&gt;  &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2><ul>
<li>没有实现的阻塞接口 LinkedList</li>
<li>实现阻塞接口的<ul>
<li>ArrayBlockingQueue ：一个由数组支持的有界队列。</li>
<li>LinkedBlockingQueue ：一个由链接节点支持的可选有界队列。</li>
<li>PriorityBlockingQueue ：一个由优先级堆支持的无界优先级队列。</li>
<li>DelayQueue ：一个由优先级堆支持的、基于时间的调度队列。</li>
<li>SynchronousQueue ：一个利用 BlockingQueue 接口的简单聚集（rendezvous）机制。</li>
</ul>
</li>
</ul>
<h3 id="Queue-的-API"><a href="#Queue-的-API" class="headerlink" title="Queue 的 API"></a>Queue 的 API</h3><table>
<thead>
<tr>
<th align="left">func</th>
<th align="left">return</th>
<th align="left">explain</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>add(E e)</strong></td>
<td align="left">boolean</td>
<td align="left">增加一个元索</td>
<td align="left">如果队列已满，则抛出一个 IIIegaISlabEepeplian 异常</td>
</tr>
<tr>
<td align="left"><strong>remove()</strong></td>
<td align="left">E</td>
<td align="left">移除并返回队列头部的元素</td>
<td align="left">如果队列为空，则抛出一个 NoSuchElementException 异常</td>
</tr>
<tr>
<td align="left"><strong>element()</strong></td>
<td align="left">E</td>
<td align="left">返回队列头部的元素</td>
<td align="left">如果队列为空，则抛出一个 NoSuchElementException 异常</td>
</tr>
<tr>
<td align="left"><strong>offer(E e)</strong></td>
<td align="left">boolean</td>
<td align="left">添加一个元素并返回true</td>
<td align="left">如果队列已满，则返回false</td>
</tr>
<tr>
<td align="left"><strong>poll()</strong></td>
<td align="left">E</td>
<td align="left">移除并返问队列头部的元素</td>
<td align="left">如果队列为空，则返回null</td>
</tr>
<tr>
<td align="left"><strong>peek()</strong></td>
<td align="left">E</td>
<td align="left">返回队列头部的元素</td>
<td align="left">如果队列为空，则返回null</td>
</tr>
<tr>
<td align="left">put(E e)</td>
<td align="left">void</td>
<td align="left">添加一个元素</td>
<td align="left">如果队列满，则阻塞</td>
</tr>
<tr>
<td align="left">take()</td>
<td align="left">E e</td>
<td align="left">移除并返回队列头部的元素</td>
<td align="left">如果队列为空，则阻塞</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——线性表</title>
    <url>/uncategorized/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>线性表</strong>属于数据结构中的线性结构，<strong>线性结构</strong>具体有以下特征：</p>
<ul>
<li>集合中必存在唯一的一个<strong>第一个元素</strong>；</li>
<li>集合中必存在唯一的一个<strong>最后的元素</strong>；</li>
<li>除最后元素之外，其它数据元素均有唯一的<strong>后继</strong>；</li>
<li>除第一元素之外，其它数据元素均有唯一的<strong>前驱</strong>；</li>
</ul>
<span id="more"></span>

<p><strong>线性表</strong>是一个含有<code>n ≥ 0</code>个结点的有限序列，对于其中的结点，有且仅有一个开始结点没有前驱但有一个后继结点，有且仅有一个终端结点没有后继但有一个前驱结点，其它的结点都有且仅有一个前驱和一个后继结点。一般地，一个线性表可以表示成一个线性序列：<code>k1，k2，…，kn</code>，其中<code>k1</code>是开始结点，<code>kn</code>是终端结点。</p>
<p>线性表包含下列基本操作：初始化、销毁、重置为空表、判断是否为空、获取长度、根据位置获取对应元素、查找元素、获取指定元素的前驱和后继元素、插入元素、删除元素、遍历元素。</p>
<h4 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h4><p>线性表的顺序表示指的是用物理上的一段连续的地址来存储数据元素，如下图所示。如果第一个元素的在内存上的地址为a1，每个元素占用的空间是l，那么第n个元素的地址就是a1+(n-1) x l。</p>
<table>
<thead>
<tr>
<th align="left">内存中的存储位置</th>
<th align="center">Row 1 is</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="left">a1 + l</td>
<td align="center">2</td>
</tr>
<tr>
<td align="left">a1 + 2l</td>
<td align="center">3</td>
</tr>
<tr>
<td align="left">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="left">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="left">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="left">a1+(n-1) x l</td>
<td align="center">n</td>
</tr>
</tbody></table>
<h4 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a>线性表的链式表示和实现</h4><p>线性表的顺序存储结构是逻辑位置和物理位置都相邻，而链式存储结构是逻辑位置相邻，但物理位置不一定相邻，相比顺序存储结构，它不能随机存取，但在插入和删除操作时不需要移动元素，大大提高了增加和删除元素的效率。</p>
<p>通常链式存储结构会有一个个结点组成，结点中包含两个域一个是数据域，一个是指针域，数据域中存储数据，指针域中存储下一个后继元素的地址，如下图所示，这一个个结点组成链表，也称<strong>线性链表</strong>或<strong>单链表</strong>。</p>
<p>除此之外，还有<strong>循环链表</strong>和<strong>双向链表</strong>。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义 Handler 的内存泄漏问题</title>
    <url>/Android/%E8%87%AA%E5%AE%9A%E4%B9%89-Handler-%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>Handler 内存泄漏一直是内存泄漏的一大常见原因。今天主要分析怎么解决这个问题。</p>
<span id="more"></span>


<ul>
<li>设为静态内部类<br>静态内部类属于 GC Root 对象，不会持有外部 Activity 的引用</li>
<li>在 onDestroy 中让 Handler.removeMessage，removeRunnable handle &#x3D; null<br>在 onDestroy 取消 Handle 执行的所有任务，释放对外的引用也是不错的办法，不过要注意的是 onDestroy 方法不一定会被调用，这种方法并不能万无一失</li>
<li>可以设 Handler 对 Activity 的弱引用<br>方法一虽然可以保证内部静态类不持有外部引用了，但是当自线程需要发消息更新主界面的时候还是需要Activity的对象引用，这时候使用弱引用可以避免内存的泄漏，当系统需要回收 Activity 的时候并不会因为 Handler 的持有而失败，使用代码如下：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static class StaticHandle extends Handler&#123;</span><br><span class="line">    WeakReference&lt;Activity&gt; mActivityReference;</span><br><span class="line"></span><br><span class="line">    public StaticHandle(Activity activity) &#123;</span><br><span class="line">        mActivityReference= new WeakReference&lt;Activity&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        Activity activity = mActivityReference.get();</span><br><span class="line">        if(activity != null&#123;</span><br><span class="line">            mTextView.setText((String)msg.obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>进程之间的通信——AIDL</title>
    <url>/Android/%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94AIDL/</url>
    <content><![CDATA[<h1 id="进程之间的通信——AIDL（Android-Interface-Definition-Language"><a href="#进程之间的通信——AIDL（Android-Interface-Definition-Language" class="headerlink" title="进程之间的通信——AIDL（Android Interface Definition Language)"></a>进程之间的通信——AIDL（Android Interface Definition Language)</h1><p>AIDL 是 Android 提供的一种进程间通信 (IPC—— Inter-Process Communication) 机制。<br>在 Android 上，一个进程通常无法访问另一个进程的内存。 每一个进程都有自己的Dalvik VM实例，都有自己的一块独立的内存，都在自己的内存上存储自己的数据，执行着自己的操作，都在自己的那片狭小的空间里过完自己的一生。每个进程之间都你不知我，我不知你。尽管如此，进程需要将其对象分解成操作系统能够识别的原语，并将对象编组成跨越边界的对象。<br>AIDL 就是 Android 为我们提供的一种跨进程的通讯方式。通过这种机制，我们只需要写好 aidl 接口文件，编译时系统会帮我们生成 Binder 接口。</p>
<span id="more"></span>

<h3 id="AIDL-支持的数据类型"><a href="#AIDL-支持的数据类型" class="headerlink" title="AIDL 支持的数据类型"></a>AIDL 支持的数据类型</h3><ul>
<li>Java 的基本数据类型</li>
<li>String 类型，CharSequence类型。</li>
<li>List 和 Map<ul>
<li>元素必须是 AIDL 支持的数据类型</li>
<li>Server 端具体的类里则必须是 ArrayList 或者 HashMap</li>
</ul>
</li>
<li>其他 AIDL 生成的接口</li>
<li>实现 Parcelable 的实体</li>
</ul>
<h3 id="AIDL-文件的分类"><a href="#AIDL-文件的分类" class="headerlink" title="AIDL 文件的分类"></a>AIDL 文件的分类</h3><p>AIDL 文件分为两种，<strong>一类</strong>是用来定义parcelable对象，以供其他AIDL文件使用AIDL中非默认支持的数据类型的。<strong>一类</strong>是用来定义方法接口，以供系统使用来完成跨进程通信的。可以看到，两类文件都是在“定义”些什么，而不涉及具体的实现，这就是为什么它叫做“Android接口定义语言”。</p>
<h3 id="AIDL-如何编写"><a href="#AIDL-如何编写" class="headerlink" title="AIDL 如何编写"></a>AIDL 如何编写</h3><p>AIDL 的编写主要为以下三部分：</p>
<ol>
<li>创建 AIDL<ol>
<li>创建要操作的实体类，实现 Parcelable 接口，以便序列化&#x2F;反序列化；</li>
<li>新建 aidl 文件夹，在其中创建接口 aidl 文件以及实体类的映射 aidl 文件；</li>
<li>Make project ，生成 Binder 的 Java 文件；</li>
</ol>
</li>
<li>服务端<ol>
<li>新建服务端工程，将在客户端定义的 aidl 接口文件拷贝至服务端并 Make project ，生成相同的 Stub 类；</li>
<li>创建 Service，在其中创建上面生成的 Binder 对象实例，继承刚才生成的 Stub ，以实现接口定义的方法；</li>
<li>在 onBind() 中返回刚才定时的 Binder；</li>
<li>在 AndroidManifest.xml 中声名创造的 Service，提供外部 Action 供客户端调用；</li>
</ol>
</li>
<li>客户端<ol>
<li>实现 ServiceConnection 接口，在其中拿到 AIDL 类；</li>
<li>bindService()，指定 Action 与 PackageName，启动相应的 Service;</li>
<li>获取通过服务端返回的 Binder ，调用 AIDL 类中定义好的操作请求，进行数据传输；</li>
</ol>
</li>
</ol>
<h3 id="AIDL-的代码实例"><a href="#AIDL-的代码实例" class="headerlink" title="AIDL 的代码实例"></a>AIDL 的代码实例</h3><p>以下是关键代码演示：<br><strong>客户端</strong></p>
<ol>
<li>先定义要传输的实体数据类型，实现 Parcelable 接口</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Person implements Parcelable &#123;</span><br><span class="line">    private String mName;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return mName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Person(Parcel in) &#123;</span><br><span class="line">        mName = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final Creator&lt;Person&gt; CREATOR = new Creator&lt;Person&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Person createFromParcel(Parcel in) &#123;</span><br><span class="line">            return new Person(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Person[] newArray(int size) &#123;</span><br><span class="line">            return new Person[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">        dest.writeString(mName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>新建 aidl 文件夹，在其中创建接口 aidl 文件以及实体类的映射 aidl 文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// PersonTransmissionInterface.aidl</span><br><span class="line">package cn.artaris.aidldemo;</span><br><span class="line"></span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line">// 非基本类型的数据需要导入，需要导入它的全路径。</span><br><span class="line">import cn.artaris.aidldemo.Person;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">interface PersonTransmissionInterface &#123;</span><br><span class="line">    //方法参数中，除了基本数据类型，其他类型的参数都需要标上方向类型</span><br><span class="line">    //in(输入), out(输出), inout(输入输出)</span><br><span class="line">    void addPerson(in Person person);</span><br><span class="line"></span><br><span class="line">    List&lt;Person&gt; getPersonList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Person.aidl</span><br><span class="line">package cn.artaris.aidldemo;</span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line">//通过 Person.aidl 接口找到真正的 实体类 Person.java</span><br><span class="line">parcelable Person;</span><br></pre></td></tr></table></figure>

<ol>
<li>Make project ，生成 Binder 的 Java 文件；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface PersonTransmissionInterface extends android.os.IInterface &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Local-side IPC implementation stub class.</span><br><span class="line">     */</span><br><span class="line">    public static abstract class Stub extends android.os.Binder implements cn.artaris.aidldemo.PersonTransmissionInterface &#123;</span><br><span class="line">        private static final java.lang.String DESCRIPTOR = &quot;cn.artaris.aidldemo.PersonTransmissionInterface&quot;;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Construct the stub at attach it to the interface.</span><br><span class="line">         */</span><br><span class="line">        public Stub() &#123;</span><br><span class="line">            this.attachInterface(this, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Cast an IBinder object into an cn.artaris.aidldemo.PersonTransmissionInterface interface,</span><br><span class="line">         * generating a proxy if needed.</span><br><span class="line">         */</span><br><span class="line">         //转换 Binder 对象，判断是本地还是远程对象</span><br><span class="line">        public static cn.artaris.aidldemo.PersonTransmissionInterface asInterface(android.os.IBinder obj) &#123;</span><br><span class="line">            if ((obj == null)) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            if (((iin != null) &amp;&amp; (iin instanceof cn.artaris.aidldemo.PersonTransmissionInterface))) &#123;</span><br><span class="line">                return ((cn.artaris.aidldemo.PersonTransmissionInterface) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            return new cn.artaris.aidldemo.PersonTransmissionInterface.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public android.os.IBinder asBinder() &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //服务器接收到数据时调用</span><br><span class="line">        @Override</span><br><span class="line">        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123;</span><br><span class="line">            java.lang.String descriptor = DESCRIPTOR;</span><br><span class="line">            switch (code) &#123;</span><br><span class="line">                case INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(descriptor);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                case TRANSACTION_addPerson: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    cn.artaris.aidldemo.Person _arg0;</span><br><span class="line">                    if ((0 != data.readInt())) &#123;</span><br><span class="line">                        _arg0 = cn.artaris.aidldemo.Person.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        _arg0 = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    this.addPerson(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                case TRANSACTION_getPersonList: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    java.util.List&lt;cn.artaris.aidldemo.Person&gt; _result = this.getPersonList();</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                default: &#123;</span><br><span class="line">                    return super.onTransact(code, data, reply, flags);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //Binder 的包装内部类，供远程传输使用</span><br><span class="line">        private static class Proxy implements cn.artaris.aidldemo.PersonTransmissionInterface &#123;</span><br><span class="line">            private android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public android.os.IBinder asBinder() &#123;</span><br><span class="line">                return mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public java.lang.String getInterfaceDescriptor() &#123;</span><br><span class="line">                return DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void addPerson(cn.artaris.aidldemo.Person person) throws android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                try &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    if ((person != null)) &#123;</span><br><span class="line">                        _data.writeInt(1);</span><br><span class="line">                        person.writeToParcel(_data, 0);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        _data.writeInt(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addPerson, _data, _reply, 0);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public java.util.List&lt;cn.artaris.aidldemo.Person&gt; getPersonList() throws android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;cn.artaris.aidldemo.Person&gt; _result;</span><br><span class="line">                try &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getPersonList, _data, _reply, 0);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createTypedArrayList(cn.artaris.aidldemo.Person.CREATOR);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                return _result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static final int TRANSACTION_addPerson = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);</span><br><span class="line">        static final int TRANSACTION_getPersonList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //实现 PersonTransmissionInterface 定义的两个接口</span><br><span class="line">    public void addPerson(cn.artaris.aidldemo.Person person) throws android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">    public java.util.List&lt;cn.artaris.aidldemo.Person&gt; getPersonList() throws android.os.RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>服务器</strong></p>
<ol>
<li>将在客户端定义的 aidl 接口文件拷贝至服务端并 Make project ，生成相同的 Stub 类<br><em>略</em></li>
<li>创建 Service，在其中创建上面生成的 Binder 对象实例，继承刚才生成的 Stub ，以实现接口定义的方法，在 onBind() 中返回刚才定时的 Binder；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PersonTransmissionService extends Service &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PersonTransmissionImpl mBinder = new PersonTransmissionImpl();</span><br><span class="line"></span><br><span class="line">    private List&lt;Person&gt; mPeople = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        Log.d(&quot;PersonService&quot;, &quot;### Transmission service created&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">    // 定义实现 aidl 接口的实现句柄类。由于 Stub 继承了 IBinder，将在onBind(Intent intent)返回 该句柄</span><br><span class="line">    class PersonTransmissionImpl extends PersonTransmissionInterface.Stub &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void addPerson(Person person) throws RemoteException &#123;</span><br><span class="line">            mPeople.add(person);</span><br><span class="line">            Log.d(&quot;PersonService&quot;, person.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public List&lt;Person&gt; getPersonList() throws RemoteException &#123;</span><br><span class="line">            return mPeople;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在 AndroidManifest.xml 中声名创造的 Service，提供外部 Action 供客户端调用；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;service android:name=&quot;.PersonTransmissionService&quot;</span><br><span class="line">    android:exported=&quot;true&quot;</span><br><span class="line">    //定义线程</span><br><span class="line">    android:process=&quot;:remote&quot;</span><br><span class="line">    android:label=&quot;@string/app_name&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        //提供 Action 供外部调用</span><br><span class="line">        &lt;action android:name=&quot;cn.artaris.aidi_server.PersonTransmissionService&quot;/&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>

<p><strong>客户端</strong></p>
<ol>
<li>实现 ServiceConnection 接口，在其中拿到 AIDL 类，通过 bindService()，指定 Action 与 PackageName，启动相应的 Service，获取通过服务端返回的 Binder ，调用 AIDL 类中定义好的操作请求，进行数据传输；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ScrollingActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    PersonTransmissionInterface mBinder;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_scrolling);</span><br><span class="line"></span><br><span class="line">        Button add = findViewById(R.id.add_person);</span><br><span class="line">        add.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View view) &#123;</span><br><span class="line">                if(mBinder == null)&#123;</span><br><span class="line">                    bindSsoAuthServices();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    addPersion();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Button get = findViewById(R.id.get_person);</span><br><span class="line">        get.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View view) &#123;</span><br><span class="line">                if(mBinder == null)</span><br><span class="line">                    return;</span><br><span class="line"></span><br><span class="line">                getPerson();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void bindSsoAuthServices()&#123;</span><br><span class="line">        //指定服务端的包名、Action名以找到对应的 Service</span><br><span class="line">        Intent intent = new Intent(&quot;cn.artaris.aidi_server.PersonTransmissionService&quot;);</span><br><span class="line">        intent.setPackage(&quot;cn.artaris.aidi_server&quot;);</span><br><span class="line">        bindService(intent,mServiceConnection,Context.BIND_AUTO_CREATE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ServiceConnection mServiceConnection = new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            //关键代码，通过</span><br><span class="line">            mBinder = PersonTransmissionInterface.Stub.asInterface(service);</span><br><span class="line">            addPersion();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    String[] name = new String[]&#123;&quot;李一&quot;,&quot;李二&quot;,&quot;李三&quot;,&quot;李四&quot;,&quot;李五&quot;,&quot;李六&quot;,&quot;李七&quot;,&quot;李九&quot;,&quot;李十&quot;&#125;;</span><br><span class="line">    int count = 0;</span><br><span class="line">    private void addPersion()&#123;</span><br><span class="line">        Log.d(&quot;ScrollingActivity&quot;,&quot;### person client addPersion&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            mBinder.addPerson(new Person(name[count++]));</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void getPerson()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Log.d(&quot;ScrollingActivity&quot;,String.valueOf(mBinder.getPersonList().size()));</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        unbindService(mServiceConnection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AIDL-原理分析"><a href="#AIDL-原理分析" class="headerlink" title="AIDL 原理分析"></a>AIDL 原理分析</h3><p>在 <code>PersonTransmissionInterface.java</code> 中自动生成了 <code>PersonTransmissionInterface</code> 接口，接口中包含了我们在<code>PersonTransmissionInterface.aidl</code> 定义的两个接口。<br>而最重要的生成了 <code>Stub</code> 类，该类继承了 Binder 类并实现了 <code>PersonTransmissionInterface</code> 接口。<br>Stub最重要的就是 <code>asInterface()</code> 这个函数，在这个函数中会自动判断参数 obj 的类型，如果 obj 是本地的接口类型，则 AIDL 会认为不是进程之间的通信，会直接返回一个本地的 <code>PersonTransmissionInterface</code> 对象；否则会转换成 <code>Stub</code> 类的一个内部类 Proxy 来包装 obj ，将其赋值给内部的 <code>mRemote</code> 字段，<code>Proxy</code> 也实现了 <code>PersonTransmissionInterface</code> 接口，不同的是他是通过 <code>Binder</code> 机制来与远程进行交互的，例如<code>mRemote.transact(Stub.TRANSACTION_addPerson, _data, _reply, 0);</code>，它请求的类型为 <code>Stub.TRANSACTION_addPerson</code>，参数为 <code>Parcel</code> 格式的 data。<br>对于服务端的代码来说，它是拥有同一份的 <code>PersonTransmissionInterface.aidl</code> 与 <code>PersonTransmissionInterface.java</code> 但不同的是服务端是指令的接口端，客户端的调用会通过 Binder 机制传递到服务端，最后到服务端调用的 <code>Stub</code> 的 <code>boolean onTransact()</code> 函数，通过 code 类型判断具体调用的函数，此时两端的传递就对应上了。<br>客户端调用了 <code>bindService(intent,mServiceConnection,Context.BIND_AUTO_CREATE);</code>之后，如果绑定成功则会调用 <code>void onServiceConnected(ComponentName name, IBinder service)</code>，这里的 <code>Service</code> 是 <code>BinderProxy</code> 经过 <code>asInterface()</code>转换以后，被包装成了 <code>Proxy</code> 对象，但是执行的时候，调用的是服务端的对应方法。即：<code>PersonTransmissionInterface</code> 的实例 <code>mBinder</code> 被服务端包装成 <code>BinderProxy</code> 类型，再经过客户端的 <code>Proxy</code> 进行包装，通过 <code>Binder</code> 机制进行包装，实现进程之间的调用。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
