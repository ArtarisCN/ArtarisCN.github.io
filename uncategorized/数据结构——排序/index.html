<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"artaris.cn","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.14.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="时间复杂度 空间复杂度 稳定性    插入排序 O(n2) O(1) 稳定   选择排序 O(n2) O(1) 不稳定   冒泡排序 O(n2) O(1) 稳定   归并排序 O(nLog2n) O(1) 稳定   快速排序 O(nLog2n) O(nLog2n) 不稳定   堆排序 O(nLog2n) (1) 不稳定   希尔排序 O(n1.5) O(1) 不稳定   桶排序 O(n)">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构——排序">
<meta property="og:url" content="http://artaris.cn/uncategorized/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/index.html">
<meta property="og:site_name" content="Artaris&#39;s Blog">
<meta property="og:description" content="时间复杂度 空间复杂度 稳定性    插入排序 O(n2) O(1) 稳定   选择排序 O(n2) O(1) 不稳定   冒泡排序 O(n2) O(1) 稳定   归并排序 O(nLog2n) O(1) 稳定   快速排序 O(nLog2n) O(nLog2n) 不稳定   堆排序 O(nLog2n) (1) 不稳定   希尔排序 O(n1.5) O(1) 不稳定   桶排序 O(n)">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-05-07T02:02:35.000Z">
<meta property="article:modified_time" content="2023-01-08T05:40:59.932Z">
<meta property="article:author" content="Artaris">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://artaris.cn/uncategorized/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://artaris.cn/uncategorized/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/","path":"uncategorized/数据结构——排序/","title":"数据结构——排序"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>数据结构——排序 | Artaris's Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Artaris's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">9</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">7</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">26</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">6.</span> <span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">7.</span> <span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">8.</span> <span class="nav-text">桶排序</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Artaris</p>
  <div class="site-description" itemprop="description">一失足成千古风流人物</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ArtarisCN" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ArtarisCN" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:i@artaris.cn" title="E-Mail → mailto:i@artaris.cn" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/5815357470" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;5815357470" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/ArtarisCN" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;ArtarisCN" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://artaris.cn/uncategorized/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Artaris">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Artaris's Blog">
      <meta itemprop="description" content="一失足成千古风流人物">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="数据结构——排序 | Artaris's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构——排序
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-07 10:02:35" itemprop="dateCreated datePublished" datetime="2018-05-07T10:02:35+08:00">2018-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-08 13:40:59" itemprop="dateModified" datetime="2023-01-08T13:40:59+08:00">2023-01-08</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <table>
<thead>
<tr>
<th align="center"></th>
<th align="center">时间复杂度</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入排序</td>
<td align="center">O(n2)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">O(n2)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">冒泡排序</td>
<td align="center">O(n2)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(nLog2n)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(nLog2n)</td>
<td align="center">O(nLog2n)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(nLog2n)</td>
<td align="center">(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">O(n1.5)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">O(n)</td>
<td align="center">O(n)</td>
<td align="center">不稳定</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>直接插入排序的核心思想就是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过。<br>因此，从上面的描述中我们可以发现，直接插入排序可以用两个循环完成：</p>
<ol>
<li>第一层循环：遍历待比较的所有数组元素</li>
<li>第二层循环：将本轮选择的元素(selected)与已经排好序的元素(ordered)相比较。找到它应该在有序队列的位置之后，将二者交换。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void insertSort(int[] num) &#123;</span><br><span class="line">    if (num == null || num.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; num.length; i++) &#123;</span><br><span class="line">        int v = num[i], j;</span><br><span class="line">        for (j = i; j &gt; 0 &amp;&amp; v &lt; num[j - 1]; j--) &#123;</span><br><span class="line">            num[j] = num[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        num[j] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序是一直非常直观的选择办法，它每次寻找当前未排序列表中最大（小）的数，放在队列的首（尾），然后从未排序的队列中取出，再找剩下队列的最值。经过<code>n-1</code>次循环排序完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void selectSort(int[] num) &#123;</span><br><span class="line">    if (num == null || num.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; num.length - 1; i++) &#123;</span><br><span class="line">        int min = i, temp;</span><br><span class="line">        for (int j = num.length - 1; j &gt; i; j--) &#123;</span><br><span class="line">            if (num[j] &lt; num[min]) &#123;</span><br><span class="line">            min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = num[min];</span><br><span class="line">        num[min] = num[i];</span><br><span class="line">        num[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是一种简单的排序算法，他依次的检查要排序的数列，每次比较两个数，如果他们顺序有误就把他们调换过来，经过依次走访，有一个最大（最小）的数据就会落座，经过<code>n-1</code>次循环排序完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void bubbleSort(int[] num) &#123;</span><br><span class="line">    if (num == null || num.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; num.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; num.length - i; j++) &#123;</span><br><span class="line">            if (num[j] &gt; num[j + 1]) &#123;</span><br><span class="line">                num[j + 1] = num[j + 1] + num[j];</span><br><span class="line">                num[j] = num[j + 1] - num[j];</span><br><span class="line">                num[j + 1] = num[j + 1] - num[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是基于归并操作的一种排序算法，即将两个已经排好序的数组合并成一个序列的操作。<br>对于使用时，使用了分治方法，即将数组递归分割成两两等分，比较再进行合并。使用时需要注意边界数据处理。<br>每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。<br>迭代方法即将步长从1增加至 n.length &#x2F; 2 ,分组排序及合并。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public static void mergeSort(int[] num) &#123;</span><br><span class="line">    if (num == null || num.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    merge(num, 0, num.length - 1, new int[num.length]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void merge(int[] num, int start, int end, int[] temp) &#123;</span><br><span class="line">    if (start &lt; end) &#123;</span><br><span class="line">        int mid = (end + start) / 2;</span><br><span class="line">        merge(num, start, mid, temp);</span><br><span class="line">        merge(num, mid + 1, end, temp);</span><br><span class="line">        mergeArray(num, start, mid, end, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void mergeArray(int[] num, int start, int mid, int end, int[] temp) &#123;</span><br><span class="line">    int i = start, j = mid + 1;</span><br><span class="line">    int k = 0;</span><br><span class="line"></span><br><span class="line">    while (i &lt;= mid &amp;&amp; j &lt;= end) &#123;</span><br><span class="line">        if (num[i] &lt; num[j])</span><br><span class="line">            temp[k++] = num[i++];</span><br><span class="line">        else if (num[i] == num[j])</span><br><span class="line">            temp[k++] = num[i++];</span><br><span class="line">        else</span><br><span class="line">            temp[k++] = num[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (i &lt;= mid)</span><br><span class="line">        temp[k++] = num[i++];</span><br><span class="line"></span><br><span class="line">    while (j &lt;= end)</span><br><span class="line">        temp[k++] = num[j++];</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; k; i++)</span><br><span class="line">        num[start + i] = temp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序（Quicksort）是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void quickSort(int[] num) &#123;</span><br><span class="line">    if (num == null || num.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _quickSort(num, 0, num.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void _quickSort(int[] num, int start, int end) &#123;</span><br><span class="line">    if (start &gt;= end)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    int t = num[start]，i = start, j = end;</span><br><span class="line"></span><br><span class="line">    while (j != i) &#123;</span><br><span class="line">        while (j &gt; i &amp;&amp; num[j] &gt;= t)</span><br><span class="line">            j--;</span><br><span class="line"></span><br><span class="line">        while (j &gt; i &amp;&amp; num[i] &lt;= t)</span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">        if (i &lt; j) &#123;</span><br><span class="line">            int temp = num[j];</span><br><span class="line">            num[j] = num[i];</span><br><span class="line">            num[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp = num[i];</span><br><span class="line">    num[i] = num[start];</span><br><span class="line">    num[start] = temp;</span><br><span class="line"></span><br><span class="line">    _quickSort(num, start, i - 1);</span><br><span class="line">    _quickSort(num, i + 1, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是根据堆的原理——堆是一个完全二叉树，切如大顶堆，每个父节点的值都大于他的子节点，当一个已经构造完成的大顶堆，每次将堆顶的数据与最后一个值调换，再将剩余的数据重新排列成一个大顶堆，重复这个过程，就构排序完成了。则问题变成了构造大顶堆及调换数字再构造的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public static void heapSort(int[] num) &#123;</span><br><span class="line">    if (num == null || num.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = num.length / 2 - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        //构造大顶堆，初始化</span><br><span class="line">        buildMaxHeap(num, i, num.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = num.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        //交换堆顶与最后一位字符的顺序</span><br><span class="line">        num[i] = num[i] + num[0];</span><br><span class="line">        num[0] = num[i] - num[0];</span><br><span class="line">        num[i] = num[i] - num[0];</span><br><span class="line"></span><br><span class="line">        //对剩下的数据继续构造大顶堆</span><br><span class="line">        buildMaxHeap(num, 0, i - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void buildMaxHeap(int[] num, int start, int end) &#123;</span><br><span class="line">    //father 为要构造的分支的父节点，son为父节点的左子树</span><br><span class="line">    int father = start, son = start * 2 + 1;</span><br><span class="line">    //son 为寻找最大数值的指针，从左子树的根节点开始，到末尾为止</span><br><span class="line">    while (son &lt;= end) &#123;</span><br><span class="line">        //如果当前指针不如根节点大，则指向右节点</span><br><span class="line">        if (son + 1 &lt; end &amp;&amp; num[son] &lt; num[son + 1]) &#123;</span><br><span class="line">            son++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (num[father] &lt;= num[son]) &#123;</span><br><span class="line">            //若根节点比左右子树都大，直接返回，否则交换根节点与左右子树的值,因为比较时是从最后一个非叶子节点开始的，所以直接比较根节点与左右子树就可以</span><br><span class="line">            num[father] = num[father] + num[son];</span><br><span class="line">            num[son] = num[father] - num[son];</span><br><span class="line">            num[father] = num[father] - num[son];</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。<br>步骤为</p>
<ul>
<li>先按照步长为一遍数组的长度，分组，进行插入排序；</li>
<li>缩小步长为刚才的一半，继续分组排序；</li>
<li>直到步长为1时经过一遍排序完成；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void shellSort(int[] num) &#123;</span><br><span class="line">    if (num == null || num.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //步长为初始数组长度的一半，最短为1</span><br><span class="line">    for (int gap = num.length / 2; gap &gt; 0; gap /= 2) &#123;</span><br><span class="line">        for (int i = gap; i &lt; num.length; i++) &#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            //冒泡排序</span><br><span class="line">            while (j - gap &gt; 0 &amp;&amp; num[j] &lt; num[j - gap]) &#123;</span><br><span class="line">                num[j] = num[j] + num[j - gap];</span><br><span class="line">                num[j - gap] = num[j] - num[j - gap];</span><br><span class="line">                num[j] = num[j] - num[j - gap];</span><br><span class="line">                j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序是一种以空间换时间的排序方法，事先要知道待排序数组的范围，申请一个空间为待排序数组最大值减去最小值的记录数组，然后依次遍历数组，出现某个数则标记相应位置+1，全部遍历完成再从小到大遍历记录数组，输出出现次数即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">int</span>[] num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE, min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : num) &#123;</span><br><span class="line">        max = Math.max(max, i);</span><br><span class="line">        min = Math.min(min, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : num) &#123;</span><br><span class="line">        bucket[i - min]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (bucket[i]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            num[index++] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/uncategorized/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="prev" title="数据结构——二叉树">
                  <i class="fa fa-chevron-left"></i> 数据结构——二叉树
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/uncategorized/OMAndroid/" rel="next" title="OMAndroid">
                  OMAndroid <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2016 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Artaris</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">37k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:16</span>
  </span>
</div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/ArtarisCN" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  





</body>
</html>
