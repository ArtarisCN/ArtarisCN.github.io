<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"artaris.cn","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.14.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一些 Java 基础知识的问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 知识整理(一、Java 基础知识)">
<meta property="og:url" content="http://artaris.cn/%E9%9D%A2%E8%AF%95/Java/Android-%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E4%B8%80%E3%80%81Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="Artaris&#39;s Blog">
<meta property="og:description" content="一些 Java 基础知识的问题。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.artaris.cn/2019-03-19-15508221786523.jpg">
<meta property="article:published_time" content="2019-03-19T01:53:03.000Z">
<meta property="article:modified_time" content="2023-01-08T05:40:59.931Z">
<meta property="article:author" content="Artaris">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.artaris.cn/2019-03-19-15508221786523.jpg">


<link rel="canonical" href="http://artaris.cn/%E9%9D%A2%E8%AF%95/Java/Android-%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E4%B8%80%E3%80%81Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://artaris.cn/%E9%9D%A2%E8%AF%95/Java/Android-%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E4%B8%80%E3%80%81Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","path":"面试/Java/Android-知识整理-一、Java-基础知识/","title":"Android 知识整理(一、Java 基础知识)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Android 知识整理(一、Java 基础知识) | Artaris's Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Artaris's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">9</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">7</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">26</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E4%B8%AD-x3D-x3D-%E5%92%8C-equals-%E5%92%8C-hashCode-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">Java 中 &#x3D;&#x3D; 和 equals() 和 hashCode() 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int%E3%80%81char%E3%80%81long%E5%90%84%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">int、char、long各占多少字节数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int-%E4%B8%8E-Integer-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">int 与 Integer 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9-Java-%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">4.</span> <span class="nav-text">谈谈对 Java 多态的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder%E5%8C%BA%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">String、StringBuffer、StringBuilder区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9F%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">6.</span> <span class="nav-text">什么是内部类？内部类的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">6.1.</span> <span class="nav-text">内部类的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">6.2.</span> <span class="nav-text">内部类的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%8C%BA%E5%88%AB"><span class="nav-number">7.</span> <span class="nav-text">抽象类和接口区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">7.1.</span> <span class="nav-text">抽象类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">8.</span> <span class="nav-text">抽象类的意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">9.</span> <span class="nav-text">抽象类与接口的应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-1"><span class="nav-number">9.1.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">9.2.</span> <span class="nav-text">接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%B2%A1%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">抽象类是否可以没有方法和属性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">11.</span> <span class="nav-text">接口的意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E4%B8%ADextends%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">12.</span> <span class="nav-text">泛型中extends和super的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%88%B6%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%83%BD%E5%90%A6%E8%A2%AB%E5%AD%90%E7%B1%BB%E9%87%8D%E5%86%99"><span class="nav-number">13.</span> <span class="nav-text">父类的静态方法能否被子类重写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">14.</span> <span class="nav-text">进程和线程的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final%EF%BC%8Cfinally%EF%BC%8Cfinalize%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">15.</span> <span class="nav-text">final，finally，finalize的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#final"><span class="nav-number">15.1.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finally"><span class="nav-number">15.2.</span> <span class="nav-text">finally</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finalize"><span class="nav-number">15.3.</span> <span class="nav-text">finalize</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">16.</span> <span class="nav-text">序列化的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Serializable-%E5%92%8C-Parcelable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">17.</span> <span class="nav-text">Serializable 和 Parcelable 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serializable-%E6%8E%A5%E5%8F%A3"><span class="nav-number">17.1.</span> <span class="nav-text">Serializable 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#serialVersionUID"><span class="nav-number">17.1.1.</span> <span class="nav-text">serialVersionUID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">17.1.2.</span> <span class="nav-text">序列化和反序列化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parcelable-%E6%8E%A5%E5%8F%A3"><span class="nav-number">17.2.</span> <span class="nav-text">Parcelable 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">17.3.</span> <span class="nav-text">区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%84%8F%E5%9B%BE"><span class="nav-number">19.</span> <span class="nav-text">静态内部类的设计意图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">20.</span> <span class="nav-text">成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9kotlin%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">21.</span> <span class="nav-text">谈谈对kotlin的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E5%92%8C%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">22.</span> <span class="nav-text">闭包和局部内部类的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-%E8%BD%AC%E6%8D%A2%E6%88%90-integer%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="nav-number">23.</span> <span class="nav-text">String 转换成 integer的方式及原理</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Artaris</p>
  <div class="site-description" itemprop="description">一失足成千古风流人物</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ArtarisCN" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ArtarisCN" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:i@artaris.cn" title="E-Mail → mailto:i@artaris.cn" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/5815357470" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;5815357470" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/ArtarisCN" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;ArtarisCN" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://artaris.cn/%E9%9D%A2%E8%AF%95/Java/Android-%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E4%B8%80%E3%80%81Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Artaris">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Artaris's Blog">
      <meta itemprop="description" content="一失足成千古风流人物">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Android 知识整理(一、Java 基础知识) | Artaris's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android 知识整理(一、Java 基础知识)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-19 09:53:03" itemprop="dateCreated datePublished" datetime="2019-03-19T09:53:03+08:00">2019-03-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-08 13:40:59" itemprop="dateModified" datetime="2023-01-08T13:40:59+08:00">2023-01-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>一些 Java 基础知识的问题。</p>
<span id="more"></span>

<h2 id="Java-中-x3D-x3D-和-equals-和-hashCode-的区别"><a href="#Java-中-x3D-x3D-和-equals-和-hashCode-的区别" class="headerlink" title="Java 中 &#x3D;&#x3D; 和 equals() 和 hashCode() 的区别"></a>Java 中 &#x3D;&#x3D; 和 equals() 和 hashCode() 的区别</h2><ul>
<li>对于基本数据类型，&#x3D;&#x3D; 是比较这两个基本数据类型的值</li>
<li>对于对象，&#x3D;&#x3D; 是比较两个对象的内存地址。equals() 是所有对象 Object 基类的一个方法，默认实现是比较两个对象的内存地址，在对于 Java 的有些类中重写了这个方法，内部使用了不同的逻辑，如 String 类的 equals() 方法是比较两个字符串是否相同。</li>
<li>hashCode()是计算一个对象的 hash 值，用在 HashMap 等对比冲突的地方<ul>
<li>相等（相同）的对象必须具有相等的哈希码（或者散列码）。</li>
<li>如果两个对象的hashCode相同，它们并不一定相同。</li>
</ul>
</li>
</ul>
<blockquote>
<p>扩展：Integer 等包装类，会有一个128大小的自有缓冲区，当一个新的 Integer 被创建时，它会先去缓冲区寻找，找到值会直接赋值给这个对象，所以两个 Integer 的值在这个缓冲区是，它们的 &#x3D;&#x3D; 方法虽然是比较它们的内存地址，但是返回是 true。</p>
<p>String 对象比较特殊，是不可变的字符串，当有新的对象创建使用 <code>String s = &quot;Hello World.&quot;;</code>时，会去缓冲区去找是否有相同的字符串，如果有就直接这个内存地址赋给这个对象。但是使用<code>String s = new String(&quot;Hello World.&quot;);</code>会直接开辟一块新的内存地址。</p>
</blockquote>
<h2 id="int、char、long各占多少字节数"><a href="#int、char、long各占多少字节数" class="headerlink" title="int、char、long各占多少字节数"></a>int、char、long各占多少字节数</h2><p><img src="http://img.artaris.cn/2019-03-19-15508221786523.jpg"></p>
<h2 id="int-与-Integer-的区别"><a href="#int-与-Integer-的区别" class="headerlink" title="int 与 Integer 的区别"></a>int 与 Integer 的区别</h2><p>int 是 Java 的基本数据类型，具体请看 <a href="http://artaris.cn/Java/int-%E4%B8%8E-Integer/">int 与 Integer</a></p>
<h2 id="谈谈对-Java-多态的理解"><a href="#谈谈对-Java-多态的理解" class="headerlink" title="谈谈对 Java 多态的理解"></a>谈谈对 Java 多态的理解</h2><p>Java 面向对象的三大特性：继承、封装、多态。</p>
<ul>
<li>封装：封装私有变量，创建公共方法供外部调用，实现了访问控制，让客户端程序员无法触及不该触及的部分，创建者通过内外分离不担心自己的修改影响了外部调用。</li>
<li>继承：</li>
<li>多态：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。</li>
</ul>
<p>实现多态的技术成为：动态绑定</p>
<h2 id="String、StringBuffer、StringBuilder区别"><a href="#String、StringBuffer、StringBuilder区别" class="headerlink" title="String、StringBuffer、StringBuilder区别"></a>String、StringBuffer、StringBuilder区别</h2><ul>
<li>String 字符串常量<br>  是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String</li>
<li>StringBuilder 字符串变量（非线程安全）<br>  可变对象</li>
<li>StringBuffer 字符串变量（线程安全）<br>  <code>append()</code>相比起 StringBuilder 来说多了一个 synchronized 关键字，会执行线程同步。</li>
</ul>
<blockquote>
<p>为啥 Java 中 String 要设计成不可变的对象</p>
<ol>
<li>字符串常量池的需要：当创建一个String对象时,假如此字符串值已经存在于常量池中,则不会创建一个新的对象,而是引用已经存在的对象。</li>
<li>安全性：String被许多的Java类(库)用来当做参数或者key,假若String不是固定不变的,将会引起各种安全隐患,容易引起中间篡改。</li>
<li>允许String对象缓存HashCode：字符串不变性保证了hash码的唯一性,因此可以放心地进行缓存.这也是一种性能优化手段,意味着不必每次都去计算新的哈希码.</li>
</ol>
</blockquote>
<h2 id="什么是内部类？内部类的作用"><a href="#什么是内部类？内部类的作用" class="headerlink" title="什么是内部类？内部类的作用"></a>什么是内部类？内部类的作用</h2><p>内部类是在类中声明的一个类</p>
<p>内部类的 new 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OuterClass outerObject = new OuterClass();</span><br><span class="line">outerClass.InnerClass innerObject = outerObject.new InnerClass();</span><br></pre></td></tr></table></figure>

<h3 id="内部类的性质"><a href="#内部类的性质" class="headerlink" title="内部类的性质"></a>内部类的性质</h3><ul>
<li>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li>
</ul>
<blockquote>
<p>当外部类的对象创建了一个内部类的对象时，内部类对象必定会秘密捕获一个指向外部类对象的引用，然后访问外部类的成员时，就是用那个引用来选择外围类的成员的。</p>
</blockquote>
<ul>
<li>内部类可以直接访问外部类的属性和方法</li>
<li>每个内部类都能独立地继承一个（接口的）实现</li>
<li>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li>
<li>创建内部类对象的时刻必须先创建了外部类之后才能创建，但之后并不依赖于外围类对象的创建。</li>
<li>成员内部类中不能存在任何 static 的变量和方法，(因为1、static类型的属性和方法，在类加载的时候就会存在于内存中。2、要使用某个类的static属性或者方法，那么这个类必须要加载到jvm中。内部类在外部类创建时没有加载，因此不能使用其 static 属性和方法)，除非内部类是 static 类。</li>
</ul>
<blockquote>
<p>此种不能同时存在的类均与 Java 的生命周期相关，内部类的生命周期是从外内部类创建之后才有的，但是静态属性是随着类的加载的，这是相互矛盾的。当内部类设为静态类时生命周期就一致了</p>
</blockquote>
<p>静态内部类</p>
<ul>
<li>静态内部类：</li>
<li>它的创建是不需要依赖于外围类的。</li>
<li>它不能使用任何外围类的非static成员变量和方法。</li>
</ul>
<p>匿名内部类</p>
<ul>
<li>可以简化代码。</li>
<li>匿名内部类是没有访问修饰符的。</li>
<li>匿名内部类是没有构造方法的。</li>
<li>匿名内部类中不能存在任何静态成员或方法。</li>
</ul>
<h3 id="内部类的作用"><a href="#内部类的作用" class="headerlink" title="内部类的作用"></a>内部类的作用</h3><ul>
<li>使用内部类可以间接实现多重继承</li>
<li>提供了更好的封装，只有外部类能访问内部类，其他类不能直接访问内部类（即是内部类是public 的也只能通过其承载的外部类访问）</li>
</ul>
<h2 id="抽象类和接口区别"><a href="#抽象类和接口区别" class="headerlink" title="抽象类和接口区别"></a>抽象类和接口区别</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>抽象类可以有自己的方法实现：接口只能定义方法，是抽象的。</li>
<li>抽象类中子类使用 extends 来继承抽象类，如果子类不是抽象类，它需要实现所有的抽象方法：接口中子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</li>
<li>抽象类可以有构造器：</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">抽象类</th>
<th align="center">接口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">继承</td>
<td align="center">子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td align="center">子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td align="center">构造器</td>
<td align="center">抽象类可以有构造器</td>
<td align="center">接口不能有构造器</td>
</tr>
<tr>
<td align="center">与实体Java类的区别</td>
<td align="center">除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td>
<td align="center">接口是完全不同的类型</td>
</tr>
<tr>
<td align="center">访问修饰符</td>
<td align="center">抽象方法可以有public、protected和default这些修饰符</td>
<td align="center">接口方法默认修饰符是public。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td align="center">main方法</td>
<td align="center">抽象方法可以有main方法并且我们可以运行它</td>
<td align="center">接口没有main方法，因此我们不能运行它。</td>
</tr>
<tr>
<td align="center">多继承</td>
<td align="center">抽象方法可以继承一个类和实现多个接口</td>
<td align="center">接口只可以继承一个或多个其它接口</td>
</tr>
<tr>
<td align="center">速度</td>
<td align="center">它比接口速度要快</td>
<td align="center">接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
<tr>
<td align="center">添加新方法</td>
<td align="center">如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td>
<td align="center">如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
<tr>
<td align="center">默认的方法实现</td>
<td align="center">它可以有默认的方法实现</td>
<td align="center">接口完全是抽象的。它根本不存在方法的实现</td>
</tr>
</tbody></table>
<h2 id="抽象类的意义"><a href="#抽象类的意义" class="headerlink" title="抽象类的意义"></a>抽象类的意义</h2><ol>
<li>为子类提供一个公共的类型；</li>
<li>封装子类中重复内容（成员变量和方法）；</li>
<li>定义有抽象方法，子类虽然有不同的实现，但该方法的定义是一致的。</li>
</ol>
<h2 id="抽象类与接口的应用场景"><a href="#抽象类与接口的应用场景" class="headerlink" title="抽象类与接口的应用场景"></a>抽象类与接口的应用场景</h2><h3 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>如果想定义一些公共方法并给其中一些方法默认实现，使用抽象类；</li>
<li>抽象类是用来捕捉子类的通用特性的，一般作为类的基类，在其中添加了一些方法不回影响到所有子类（子类不需要全部覆盖）；</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>多重继承只能使用接口；</li>
<li>作为两个类的通信协议，传递一些信息或者数据时，定义接口；</li>
</ul>
<h2 id="抽象类是否可以没有方法和属性？"><a href="#抽象类是否可以没有方法和属性？" class="headerlink" title="抽象类是否可以没有方法和属性？"></a>抽象类是否可以没有方法和属性？</h2><p>可以没有方法和属性。<br>抽象类的作用在于子类对其的继承和实现，也就是多态；而没有抽象方法的抽象类的存在价值在于：<strong>实例化了没有意义，因为类已经定义好了，不能改变其中的方法体，但是实例化出来的对象却满足不了要求，只有继承并重写了他的子类才能满足要求。所以才把它定义为没有抽象方法的抽象类</strong></p>
<ul>
<li>抽象类专用于派生出子类，子类必须实现抽象类所声明的抽象方法，否则，子类仍是抽象类。</li>
<li>包含抽象方法的类一定是抽象类，但抽象类中的方法不一定是抽象方法。</li>
</ul>
<h2 id="接口的意义"><a href="#接口的意义" class="headerlink" title="接口的意义"></a>接口的意义</h2><ul>
<li>接口体现了抽象的特点，抽象的定义就是抽取像的部分，可以提取一些类的共性。</li>
<li>接口并不负责具体的操作，具体的操作是由接口的实现类完成的</li>
<li>接口具有简单，规范性：实现相同接口的类可以替换，他们遵循相同的规范，实现了相同的功能。</li>
<li>接口具维护、拓展性：在之后代码中可以随时替换类，只要这些类实现了相同的接口，接口具有规范性</li>
<li>接口具有安全、严密性：在两个类进行通信的时候，并不公开全部的内部代码，只要通过接口进行通信即可</li>
<li></li>
</ul>
<h2 id="泛型中extends和super的区别"><a href="#泛型中extends和super的区别" class="headerlink" title="泛型中extends和super的区别"></a>泛型中extends和super的区别</h2><p>简单来说，&lt;? super T&gt;表示包括T在内的任何T的父类，&lt;? extends T&gt;表示包括T在内的任何T的子类。</p>
<ul>
<li><? extends T> 只能用于方法返回，告诉编译器此返参的类型的最小继承边界为T，T和T的父类都能接收，但是入参类型无法确定，只能接受null的传入</li>
<li><? super T>只能用于限定方法入参，告诉编译器入参只能是T或其子类型，而返参只能用Object类接收</li>
<li>? 既不能用于入参也不能用于返参</li>
</ul>
<h2 id="父类的静态方法能否被子类重写"><a href="#父类的静态方法能否被子类重写" class="headerlink" title="父类的静态方法能否被子类重写"></a>父类的静态方法能否被子类重写</h2><p>不可以。<br>**所谓静态就是指：在编译之后所分配的内存会一直存在（不会被回收），直到程序退出内存才会释放这个空间。<br>**<br>静态方法只与类有关，不与实例有关，重写只适用于实例方法，不适用于静态方法。</p>
<p>因为静态方法是程序一运行就已经分配好了内存地址，而且该地址是固定的，所有引用到该方法的对象（父类或者子类）所指向的始终是同一个内存地址中的数据，即该静态方法。如果子类定义了相同名称的静态方法，只会新增一个内存地址，并不会重写。</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>进程和线程都是一个时间段的描述，是CPU工作时间段的描述。</p>
<p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>
<p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.<br>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.<br>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p>
<p>进程包括自己独立的地址空间、堆栈和局部变量，线程共享进程的地址空间、堆栈和局部变量。<br>进程切换的时候需要切换上下文，耗费资源较大。</p>
<h2 id="final，finally，finalize的区别"><a href="#final，finally，finalize的区别" class="headerlink" title="final，finally，finalize的区别"></a>final，finally，finalize的区别</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>用于申明属性，方法和类，表示属性不可变，方法不可以被覆盖，类不可以被继承。</p>
<ul>
<li>变量<br>  final修饰变量表示该变量是不可变的。当指向一个对象时：指向的内存地址是不变的，但是被指的内存地址中的类是可以改变的。</li>
<li>方法<br>  final修饰方法时表示该方法是不能被子类重写的。</li>
<li>类<br>  final修饰类时表示该类是不能被继承的，由于java的单继承关系，所以该类是继承关系链中的终端。</li>
</ul>
<p>接口中声明的所有变量都是final的；</p>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>是异常处理语句结构中，表示总是执行的部分。　　<br>具体请看 <a href="http://artaris.cn/Java/try%E3%80%81catch%E3%80%81finally%E3%80%81throw%E5%92%8Cthrows/">try、catch、finally、throw和throws</a></p>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><p>表示是object类一个方法，在垃圾回收机制中执行的时候会被调用被回收对象的方法。允许回收此前未回收的内存垃圾。所有object都继承了 <code>finalize()</code> 方法</p>
<h2 id="序列化的方式"><a href="#序列化的方式" class="headerlink" title="序列化的方式"></a>序列化的方式</h2><p>将序列化的数据实现 Serializable&#x2F;Parcelable 接口，通过 Intent.putExtra 或者 Binder 传递数据。</p>
<h2 id="Serializable-和-Parcelable-的区别"><a href="#Serializable-和-Parcelable-的区别" class="headerlink" title="Serializable 和 Parcelable 的区别"></a>Serializable 和 Parcelable 的区别</h2><h3 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h3><p>实现非常简单，出了需要继承 Serializable 接口外只要创建一个 serialVersionUID 属性就好。</p>
<h4 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h4><p>serialVersionUID 在运行时唯一标识了一个可序列化的类。一个类序列化时，运行时会保存它的版本号，然后在反序列化时检查你要反序列化成的对象版本号是否一致，不一致的话就会报错：InvalidClassException。</p>
<h4 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h4><p>Serializable 的序列化与反序列化分别通过 ObjectOutputStream 和 ObjectInputStream 进行，实例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 序列化对象</span><br><span class="line"> *</span><br><span class="line"> * @param obj</span><br><span class="line"> * @param path</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">synchronized public static boolean saveObject(Object obj, String path) &#123;</span><br><span class="line">    if (obj == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    ObjectOutputStream oos = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        oos = new ObjectOutputStream(new FileOutputStream(path));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">        oos.close();</span><br><span class="line">        return true;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (oos != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 反序列化对象</span><br><span class="line"> *</span><br><span class="line"> * @param path</span><br><span class="line"> * @param &lt;T&gt;</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&quot;unchecked &quot;)</span><br><span class="line">synchronized public static &lt;T&gt; T readObject(String path) &#123;</span><br><span class="line">    ObjectInputStream ojs = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        ojs = new ObjectInputStream(new FileInputStream(path));</span><br><span class="line">        return (T) ojs.readObject();</span><br><span class="line">    &#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        close(ojs);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Parcelable-接口"><a href="#Parcelable-接口" class="headerlink" title="Parcelable 接口"></a>Parcelable 接口</h3><p>Parcelable 是 Android 特有的序列化方式<br>实现 Parcelable 的方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class ParcelClass implements Parcelable &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public int id;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 系统自动添加，给createFromParcel里面用</span><br><span class="line">     * @param in</span><br><span class="line">     */</span><br><span class="line">    protected ParcelClass(Parcel in) &#123;</span><br><span class="line">        name = in.readString();</span><br><span class="line">        id = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 序列话数据</span><br><span class="line">     * @param dest</span><br><span class="line">     * @param flags</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeInt(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 内容接口描述，默认返回0即可。</span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final Creator&lt;ParcelClass&gt; CREATOR = new Creator&lt;ParcelClass&gt;() &#123;</span><br><span class="line">        /**</span><br><span class="line">         *</span><br><span class="line">         * @param in</span><br><span class="line">         * @return</span><br><span class="line">         * createFromParcel()方法中我们要去读取刚才写出的name和age字段，</span><br><span class="line">         * 并创建一个Person对象进行返回，其中 name 和 id 都是调用Parcel的readXxx()方法读取到的，</span><br><span class="line">         * 注意这里读取的顺序一定要和刚才写出的顺序完全相同。</span><br><span class="line">         * 读取的工作我们利用一个构造函数帮我们完成了</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public ParcelClass createFromParcel(Parcel in) &#123;</span><br><span class="line">            return new ParcelClass(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //供反序列化本类数组时调用的</span><br><span class="line">        @Override</span><br><span class="line">        public ParcelClass[] newArray(int size) &#123;</span><br><span class="line">            return new ParcelClass[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>编码上：</li>
</ul>
<p>Serializable代码量少，写起来方便<br>Parcelable代码多一些</p>
<ul>
<li>效率上：</li>
</ul>
<p>Parcelable的速度比高十倍以上。<br>Serializable 这种方法的缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。</p>
<h2 id="静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"><a href="#静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？" class="headerlink" title="静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"></a>静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</h2><p>可以被继承，不可以被重写。</p>
<ol>
<li>静态方法和属性是属于类的，调用的时候直接通过类名.方法名完成对，不需要继承机制即可以调用。如果子类里面定义了静态方法和属性，那么这时候父类的静态方法或属性称之为”隐藏”。如果你想要调用父类的静态方法和属性，直接通过父类名.方法或变量名完成，至于是否继承一说，子类是有继承静态方法和属性，但是跟实例方法和属性不太一样，存在”隐藏”的这种情况。</li>
<li>多态之所以能够实现依赖于继承、接口和重写、重载（继承和重写最为关键）。有了继承和重写就可以实现父类的引用指向不同子类的对象。重写的功能是：”重写”后子类的优先级要高于父类的优先级，但是“隐藏”是没有这个优先级之分的。</li>
<li>静态属性、静态方法和非静态的属性都可以被继承和隐藏而不能被重写，因此不能实现多态，不能实现父类的引用可以指向不同子类的对象。非静态方法可以被继承和重写，因此可以实现多态。</li>
</ol>
<h2 id="静态内部类的设计意图"><a href="#静态内部类的设计意图" class="headerlink" title="静态内部类的设计意图"></a>静态内部类的设计意图</h2><ul>
<li>它的创建是不需要依赖于外围类的。</li>
<li>它不能使用任何外围类的非static成员变量和方法。</li>
</ul>
<h2 id="成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用"><a href="#成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用" class="headerlink" title="成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用"></a>成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用</h2><p>具体请看 <a href="## 什么是内部类？内部类的作用">内部类</a></p>
<h2 id="谈谈对kotlin的理解"><a href="#谈谈对kotlin的理解" class="headerlink" title="谈谈对kotlin的理解"></a>谈谈对kotlin的理解</h2><p>&#x2F;&#x2F;TODO</p>
<h2 id="闭包和局部内部类的区别"><a href="#闭包和局部内部类的区别" class="headerlink" title="闭包和局部内部类的区别"></a>闭包和局部内部类的区别</h2><p>局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p>
<h2 id="String-转换成-integer的方式及原理"><a href="#String-转换成-integer的方式及原理" class="headerlink" title="String 转换成 integer的方式及原理"></a>String 转换成 integer的方式及原理</h2><p>进过一系列判断，最后负着一直加首位的数，再乘以十，最后负的返回原值，正的返回相反数</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/Java/Java-%E4%B8%AD%E5%8D%95%E4%BE%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" rel="prev" title="Java 中单例的实现与线程安全">
                  <i class="fa fa-chevron-left"></i> Java 中单例的实现与线程安全
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2016 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Artaris</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">37k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:16</span>
  </span>
</div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/ArtarisCN" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  





</body>
</html>
